presentations:
- subtitle: ""
  title: "Bootstrapping iOS Application Development"
  author: "Chris Zelenak"
  date: "12/02/2013"
  sections:
  - "Intro to class":
      slides:
        - >
          Welcome to the 5-Day Bootstrapping iOS Application Development class. Over the course of these next 5 days, we're going to be reviewing Objective C, UIKit, Core Animation, Core Data, and a host of other technologies you may only know by name.
  - "Lab 1":
    - "Create a new iPhone Project":
        slides:
          - >
            Create a new Single View based application in XCode called Lab1 \menu{File > New > Project}

            <% figure("New Projects") do %>
              <%= graphic("NewProject.png", 0.5) %>
            <% end %>
          - >
            Open Main.storyboard in Interface Builder

            <% figure("Main Storyboard") do %>
              <%= graphic("MainStoryboard.png", 0.5) %>
            <% end %>
    - "Add a button":
        slides:
          - >
            Add a button with the text "Hello iPhone"

            <% figure("Drag Button to Storyboard") do %>
              <%= graphic("DragButtonToStoryboard.png", 0.5) %>
            <% end %>
    - "Connect the button to the view controller":
        slides:
          - >
            Add an IBAction selector to the view controller

            ```objectivec
              // In the ViewController.h file
              -(IBAction) helloWorldTapped:(id)sender;
            ```
          - >
            Make it open an alert view

            ```objectivec
              // In the ViewController.m file
              -(IBAction) helloWorldTapped:(id)sender {
                  [[[UIAlertView alloc] initWithTitle:@"Yay it worked"
                                              message:@"Hello World"
                                             delegate:nil
                                    cancelButtonTitle:@"Dismiss"
                                    otherButtonTitles: nil] show];
              }
            ```
          - >
            Connect the `IBAction` to the Button's `Touch Up Inside` action.

            <% figure("Connect Touch Up Inside event to IBAction") do %>
              <%= graphic("ConnectTouchUpToHelloWorld.png", 0.5) %>
            <% end %>
    - "Build and run in simulator":
        slides:
          - >
            Run the simulator with \keys{\cmd + R}, the \menu{Product > Run} menu, or the Play button

            <% figure("Launch Simulator") do %>
              <%= graphic("LaunchInSimulator.png", 0.5) %>
            <% end %>
          - >
            <% figure("It Worked!") do %>
              <%= graphic("YayItWorked.png", 0.5) %>
            <% end %>
  - "Objective C":
    - "Overview":
        slides:
          - >
            Objective C is a superset of C. It tacks on to C a message-passing object model similar to Smalltalk's (see Ruby), with support for reflection and limited runtime dynamic programming.
          - >
            Objective C allows you to use weak and dynamicly typed language features along with the static typing of C; it also allows you to take advantage of runtime method resolution, so that your object's implementation of certain messages may be determined at call-time rather than at compile-time.
          - >
            The language is still physically identical to C in many ways, in that the bulk of your development will be alternating between header files (.h files) and implementation files (.m files). You will also be doing a lot of memory management, which may fill you with either fear or joy, depending on your experience with garbage collected languages.
          - >
            You will also be dealing a lot with many other C-family familiars, such as enumerated integer constants (enums), structs, pass-by-reference v. pass-by-value semantics and pointers.  You don't need to have a very strong grasp on these things immediately, but the more iPhone programming and Objective C programming you do, the more your skills will benefit from a firm grasp of C.
        notes: |
          Objective C is a language similar in many ways to Smalltalk or Ruby. This similarity lies primarily in its object system; objects receive "messages", and may respond to them through statically known methods or runtime selected methods.
          What many people refer to as "Objective C" is actually the various Cocoa family frameworks that Apple has provided, and enhancements to the tooling infrastructure. You could think of Apple's frameworks as the _Standard Library_ of Objective C, much like Ruby or C++'s  standard library.
    - "Review of standard C elements":
        slides:
          - >
            # Variables

            Variable declaration in C follows the form `TYPE_DESCRIPTION NAME`, eg:

            ```c
              int i = -1; // just an integer
              unsigned int k = 0; // an unsigned integer
              const unsigned int j = 0; // a constant unsigned integer, no reassignment
              const char c = 'c'; // a constant char
              const char * s = "a constant string"; // a read only pointer to a char array
            ```

            \begin{figure}[htb]\begin{center}\caption{001\_variables.c}\end{center}\end{figure}
          - >
            These are items you'll commonly encouter while doing iPhone programming whose roots belong in the C family:

            ```c
              typedef enum {
                NONE = 0,
                SOME,
                ALL
              } HowMany;

              HowMany i = SOME; // Use of enumerated constant
            ```

            \begin{figure}[htb]\begin{center}\caption{002\_enumerations.c}\end{center}\end{figure}

            Note the `typedef` in this example, which is creating a type alias to be used later.
          - >
            # Structs

            ```c
              // Declaring a point in space type
              typedef struct {
                float x;
                float y;
              } APointInSpace;

              APointInSpace point;
              point.x = 20.0;
              point.y = 410.0;

              // C99 style struct instantiation
              APointInSpace point2 = { .x= 21.0, .y=32.0 };
            ```

            \begin{figure}[htb]\begin{center}\caption{003\_typedef.c}\end{center}\end{figure}
          - >
            # Arrays and Pointers

            ```c
              #include <stddef.h>

              // a constant byte array
              char * constantCharArray = "Or in other words, a string";

              // C99 style array instantiation
              int aListOfNumbers[5] = { 1, 2, 3, 4, 5 };
              int aListOfNumbers2[] = { 1, 2, 3, 4, 5};

              // C99 Variable length array declaration
              int someLength = 5;
              float aListOfFloats[someLength];

              // pointer declaration to NULL
              int * someIntegerPtr = NULL;
              int someInteger = 5;

              // address dereference
              someIntegerPtr = &someInteger;
            ```

            \begin{figure}[htb]\begin{center}\caption{004\_arrays\_and\_pointers.c}\end{center}\end{figure}
          - >
            # Functions and Function Pointers

            ```c
              float aSimpleAdditionMethod(float a, float b){
                return a + b;
              }

              float aSimpleSubtractionMethod(float a, float b){
                return a - b;
              }

              int aFloatAdditionThatReturnsAnInt(float a, float b){
                return (int) (a + b);
              }

              float (*anFnPtr)(float, float) = aSimpleAdditionMethod;
              anFnPtr(1, 1); // returns 2
              anFnPtr = aSimpleSubtractionMethod;
              anFnPtr(1, 1); // returns 0
            ```

            \begin{figure}[htb]\begin{center}\caption{005\_functions.c}\end{center}\end{figure}
          - >
            # Preprocessor Statements

            ```c
              #include <stdio.h>
              #define FOO 1
              #define IS_ZERO(n) (n == 0)

              int main(){
                printf("FOO is %i\n", FOO);
                if(IS_ZERO(0)) {
                  printf("This code is very useful.\n");
                }
              }
            ```

            \begin{figure}[htb]\begin{center}\caption{006\_preprocessor.c}\end{center}\end{figure}
          - >
            If you never learned C or it's been a long time, a fantastic book for you is ["The C Programming Language"](http://www.amazon.com/C-Programming-Language-2nd-Edition-ebook/dp/B009ZUZ9FW/ref=dp_kinw_strp_1). It doesn't cover many of the newer items in [C99](http://en.wikipedia.org/wiki/C99), but it is a thorough reference to the language fundamentals.

            If you'd like to read more about the new features introduced by C99, read more at [C99Changes](http://home.datacomm.ch/t_wolf/tw/c/c9x_changes.html).
        notes: |
          While it would be disinegenuous to say that C is "easy", its syntax is simple to learn. The underlying concepts and dearth of a 'modern' standard library is where a large part of the perceived difficulty may lie.
          It is important to realize that through the course of your career writing Objective C, a large part of the code and concepts you will be using come from the C world; in reality they are not unique to C at all, but are a closer representation to how a computer models memory and computation.
          An effective way to think about C is as a high level portable assembler; while the output is not portable to different architectures, the source may be cross compiled in a cross platform manner. ( With the understanding that you did not add any platform specificity to your code. :) )
    - "Syntax":
        slides: >
          # Some typical Objective C code

          ```objectivec
            NSString * anExampleString = @"This is a pointer to an NSString object";
            int strLen = [anExampleString length];

            NSString * aSecondString = [anExampleString
              stringByAppendingString:@" that had a second string appended to it"];

            if([anExampleString
                 compare:@"this is a pointer to an nsstring object"
                 options:NSCaseInsensitiveCompare] == NSOrderedSame){
              NSLog(@"The string %@ was case insensitive equal", anExampleString);
            }
          ```

          \begin{figure}[htb]\begin{center}\caption{007\_basic\_objc\_example.m}\end{center}\end{figure}
    - "Calling functions":
        slides:
          - >
            Given some Objective C object, like:

            ```objectivec
              NSString * anObject = @"TheObject";
            ```

            you can invoke functionality on that object via the form:

            ```objectivec
             [anObject theMethodName];
            ```

            Method names in Objective C follow the form `initialMethodNameAndArgument:theSecondArgument:theThirdArgument:` .
          - >
            # Method calling behavior

            When you see references to "calling a method" or "calling a function" on an object in Objective C, it's best to consider these synonymous with "dispatching a message". Objective C objects respond to __messages__, and as you work more with Objective C, it will be more beneficial for you to perceive this as such.
    - "nil, NULL":
        slides: >
          An object in Objective C may be nil; nil is a "special" object which may have any message at all sent to it, to which it will respond with a nil object.

          ```objectivec
            NSString * anObject = nil;
            if([anObject whoaThisProbablyDoesntExist] == nil){
              NSLog(@"Ah well");
            }
          ```

          \begin{figure}[htb]\begin{center}\caption{008\_calling\_methods\_on\_nil.m}\end{center}\end{figure}

          nil is the appropriate null object when dealing with pointers to Objective C classes; NULL, on the other hand, is the appropriate null value to use when dealing with pointers to all other types.
        notes: |
          Of course, there is also the unfortunately necessary NSNull object, which pops up in cases where the framework needs to formally recognize a deserialized NULL value (see Property Lists, JSON, etc.). You can test if an object is an NSNull object by comparing it `[NSNull null]`.
    - "Basic Types":
        slides:
          - >
            There are a host of useful classes in the Cocoa Touch framework that provide special functionality to you.  Some of the more common objects you'll use in your programming are NSArray, NSDictionary, NSNumber and NSString.  Each of these objects have mutable versions that allow you to modify them after instantiation.
          - >
            # The id type

            The special type `id` refers to any valid NSObject or its subclass. You can use the `id` type when you're not sure what sort of object you may be given.
          - >
            # NSString usage

            NSString is an enhanced, unicode aware string class that goes far beyond the simple byte-array behavior of C's byte-array strings.

            ```objectivec
              NSString * s = @"This is an NSString";
              NSMutableString * so = [[NSMutableString alloc]
                                              initWithString:@"This is a mutable string"];

              [so appendString:s];

              NSLog(@"The mutable string is %@", so);
            ```

            \begin{figure}[htb]\begin{center}\caption{008\_nsstring\_example.m}\end{center}\end{figure}
          - >
            # NSNumber usage

            NSNumber is a simple abstract wrapper around numeric values which allows you to automatically convert its held value to the appropriate form, as well as having an object-like representations of a numeric value.

            ```objectivec
              NSNumber * n = @(20.0f);
              double d = [n doubleValue];
              int i = [n intValue];
              NSNumber * b = @(YES);
              NSLog(@"Number is %@, double value is %f, int value is %i", n, d, i);
              NSLog(@"Boolean number is %@, bool value is %i", b, [b boolValue]);
            ```

            \begin{figure}[htb]\begin{center}\caption{009\_nsnumber\_example.m}\end{center}\end{figure}
          - >
            NSDictionary is a generic dictionary object that you can use to hold key/value associations. A key can be any NSObject that responds to isEqual: and NSCopying; in most cases, your keys will be either NSString or NSNumber objects.
          - >
            # NSDictionary usage

            ```objectivec
              NSDictionary * a = @{
                @"Foo": @"The Foo string",
                @"Bar": @"The Bar string"
              };

              NSMutableDictionary * b = [[NSMutableDictionary alloc] init];
              [b setObject:@"Another string" forKey:@(20)];

              NSLog(@"a's value for Foo is %@, and b's value for 20 is %@",
                                        [a objectForKey:@"Foo"],
                                        [b objectForKey:@(20)]);

              for(id key in a){
                NSLog(@"The value for %@ is %@", key, [a objectForKey:key]);
              }
            ```

            \begin{figure}[htb]\begin{center}\caption{010\_nsdictionary\_example.m}\end{center}\end{figure}
          - >
            # NSArray usage

            NSArray is a simple way to collect NSObject inheriting classes into a sequential list.  NSArray automatically retains each object added to it, and releases each object it holds once its own retain count has reached 0.

            ```objectivec
              NSArray * a = @[@"Foo", @"bar", @"baz"];
              NSMutableArray * b = [[NSMutableArray alloc] init];
              [b addObject:@"Not foo"];
              NSLog(@"The contents of a are %@ and b are %@", a, b);

              for(id obj in a){
                NSLog(@"The array contains %@", obj);
              }
            ```

            \begin{figure}[htb]\begin{center}\caption{011\_nsarray\_example.m}\end{center}\end{figure}
          - >
            NSArray, NSDictionary, NSString and NSNumber may all be represented by the contents of a property list file ( Plist ).  You can easily rebuild an NSArray or NSDictionary full of the property list contents by using the initialization method `initWithContentsOfFile:`
          - >
            # Property List Deserialization

            <% figure("Sample Property List") do %>
              <%= graphic("PListExample1.png", 0.5) %>
            <% end %>

            ```objectivec
              NSDictionary * example = [[NSDictionary alloc]
                                           initWithContentsOfFile:@"/path/to/sample.plist"];
              NSLog(@"The subarray contents are %@",
                         [example objectForKey:"A subarray of values"]);
            ```

            \begin{figure}[htb]\begin{center}\caption{012\_plist\_example.m}\end{center}\end{figure}
          - >
            Apple also provides JSON serialize/deserialize capability in the `NSJSONSerialization` class. This class can decode NSString, NSNumber, NSArray and NSDictionary values much like property lists.

            ```objectivec
              NSDictionary * dict = @{ @"foo": @"bar" };
              NSData * jsonData = [NSJSONSerialization dataWithJSONObject:dict
                                                                  options:0
                                                                    error:nil];
              if([jsonData writeToFile:@"./test.json" atomically:YES]){
                NSData * inputJsonData = [NSData dataWithContentsOfFile:@"./test.json"];
                id jsonDict = [NSJSONSerialization JSONObjectWithData:inputJsonData
                                                                options:0
                                                                  error:&error];
                NSLog(@"Foo's value is %@", [jsonDict objectForKey:@"foo"]);
              }
            ```

            \begin{figure}[htb]\begin{center}\caption{013\_json\_example.m}\end{center}\end{figure}
    - "Classes":
        slides:
          - >
            # Class interface declaration

            Classes in Objective C are similar to their C++ cousins in that they come in two parts: interface declaration and implementation. The interface declaration portion of a class follows the form:


            ```objectivec
              #import <Foundation/Foundation.h>
              @interface MyNewClass : NSObject {
                int privateVariable1;
                NSString * privateVariable2;
              }

              +(int) someClassMethod;
              -(void) doSomething;
              -(NSString *) giveMeAStringOfLength:(int)length
                                randomizeContents:(BOOL)randomize;
              @end
            ```

            \begin{figure}[htb]\begin{center}\caption{014\_objects.m part 1}\end{center}\end{figure}
          - >
            # Class implementation

            The implementation of this class follows the form:

            ```objectivec
              #import "MyNewClass.h"

              @implementation MyNewClass

              -(id) init {
                self = [super init];
                if(self){
                  privateVariable1 = 20;
                  privateVariable2 = [[NSString alloc] initWithString:@"Test"];
                }
                return self;
              }

              +(int) someClassMethod {
                return 0;
              }

            ```

            \begin{figure}[htb]\begin{center}\caption{014\_objects.m part 2}\end{center}\end{figure}
          - >
            # Class implementation pt. 2

            ```objectivec
              -(void) doSomething {
                NSLog(@"Something");
              }

              -(NSString *) giveMeAStringOfLength:(int)length
                                randomizeContents:(BOOL)randomize {
                return @"TODO: Make work";
              }

              @end
            ```

            \begin{figure}[htb]\begin{center}\caption{014\_objects.m part 3}\end{center}\end{figure}
    - "Properties":
        slides:
          - >
            Much of the interaction with Objective C objects equates to the usual getter/setter functionality commonly associated with Object Oriented Programming. To make it easier for programmers to declare this functionality, properties were introduced as a way to eschew all the boilerplate code and provide a common framework upon which to enhance Objective C objects.
          - >
            # Property interface declaration

            ```objectivec
              @interface MyObject : NSObject {

              }
              @property(strong) NSString * instanceVariable;
              @property float numericVariable;
              @end

              @implementation MyObject

              @end
            ```

            \begin{figure}[htb]\begin{center}\caption{015\_properties.m part 1}\end{center}\end{figure}
          - >
            # Property usage

            ```objectivec
              MyObject * mo = [[MyObject alloc] init];

              // Bracket Syntax
              [mo setInstanceVariable:@"Test"];
              [mo setNumericVariable:20.0f];
              NSLog(@"The values I set were %@ and %f",
                      [mo instanceVariable],
                      [mo numericVariable]);

              // Dot Syntax
              mo.instanceVariable = @"Test 2";
              mo.numericVariable = 25.0f;
              NSLog(@"The values I set were %@ and %f",
                      mo.instanceVariable,
                      mo.numericVariable);
            ```

            \begin{figure}[htb]\begin{center}\caption{015\_properties.m part 2}\end{center}\end{figure}
          - >
            You can specify the memory management semantics (strong, weak, copy), atomicity (locking behavior), and access level in the property declaration. You can also specify your own implementation of the getter and setter methods.

            ```objectivec
              @property(readonly) NSString * privateName;
              @property(weak, nonatomic, setter=myAgeSetter:) NSNumber * age;
            ```

            \begin{figure}[htb]\begin{center}\caption{016\_advanced\_properties.m}\end{center}\end{figure}
          - >
            # Key Value Observing

            Properties do not merely provide getter/setter functionality.  The use of properties also implicitly adds Key-Value-Observing functionality to your class, letting you automatically monitor classes for change events and performing specific code in such cases.  Read more in the [SDK Documentation on properties](https://developer.apple.com/library/mac/documentation/cocoa/conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html) and [Key Value Observing](https://developer.apple.com/library/mac/documentation/cocoa/conceptual/KeyValueCoding/Articles/KeyValueCoding.html#//apple_ref/doc/uid/10000107i).
    - "Selectors":
        slides:
          - >
            Selectors in Objective C are a way to indicate a message as a variable. They allow you to dynamically send a message to an object, as well as to query an object to see if it responds to a given message.
          - >
            # Selector usage

            ```objectivec
              SEL aSelector = @selector(length);
              NSString * foo = @"Foo";
              if([foo respondsToSelector:aSelector]){
                NSLog(@"The length of foo is %i",  [foo performSelector:aSelector]);
              }
            ```

            \begin{figure}[htb]\begin{center}\caption{017\_selectors.m}\end{center}\end{figure}
          - >
            # Other selector usage

            Selectors can be built from strings, and can refer to any Objective C message that is forwarded to an object.

            ```objectivec
              NSString * anAllCapsString = @"THIS STRING SHOULD BE LOWERCASE";
              NSString * theMessageToSend = @"lowercaseString";
              SEL aSelector = NSSelectorFromString(theMessageToSend);
              if([anAllCapsString respondsToSelector:aSelector]){
                NSLog(@"All caps string (%@) converted: %@",
                            anAllCapsString,
                            [anAllCapsString performSelector:aSelector]);
              }
            ```

            \begin{figure}[htb]\begin{center}\caption{018\_advanced\_selectors.m}\end{center}\end{figure}
    - "Protocols":
        slides:
          - >
            Objective C provides only single-inheritance for its objects; to allow for situations where a class may provide functionality outside of its inheritance chain, the language provides Protocols, which are roughly analogous to interfaces in Java and C#.  There are informal protocols (only referred to in documentation) and formal protocols, which are compiler checked.  The majority of protocol usage in iOS programming is formal protocols.
          - >
            # Protocol declaration

            ```objectivec
              @protocol CameraDevice

              -(NSString *) manufacturerName;

              @optional

              -(int) flashStrength;

              @end

              @interface AnExpensiveCanonCamera : NSObject<CameraDevice>
              @end

              @interface TheCheapestCameraEver : NSObject<CameraDevice>
              @end
            ```

            \begin{figure}[htb]\begin{center}\caption{019\_protocols.m part 1}\end{center}\end{figure}
          - >
            # Protocol usage

            ```objectivec
              NSArray * cameras = @[
                [[AnExpensiveCanonCamera alloc] init],
                [[TheCheapestCameraEver alloc] init]
              ];
              for(NSObject<CameraDevice> * camera in cameras){
                if([camera respondsToSelector:@selector(flashStrength)]){
                  NSLog(@"%@ camera has flash strength %i",
                                [camera manufacturerName],
                                [camera flashStrength]);
                } else {
                  NSLog(@"%@ camera has no flash", [camera manufacturerName]);
                }
              }
            ```

            \begin{figure}[htb]\begin{center}\caption{019\_protocols.m part 2}\end{center}\end{figure}
    - "Categories":
        slides:
          - >
            Categories allow you to mix in new code to existing classes without having to change the original source code for those classes.  Examples of categories include automatically adding special serialization rules to NSObject.
          - >
            You "can't" add instance variables to a class with categories; they are purely for adding new methods to a class, but cannot change the memory layout of a class after the fact.
          - >
            # Category declaration

            ```objectivec
              @interface NSDictionary(AsJson)

              -(NSString *) asJson;

              @end

              @implementation NSDictionary(AsJson)

              -(NSString *) asJson {
                  NSData * jsonData = [NSJSONSerialization dataWithJSONObject:self
                                                                      options:0
                                                                        error:nil];
                  return [[NSString alloc] initWithData:jsonData
                                               encoding:NSUTF8StringEncoding];
              }

              @end
            ```

            \begin{figure}[htb]\begin{center}\caption{020\_categories.m part 1}\end{center}\end{figure}
          - >
            # Category usage

            ```objectivec
              #import "NSDictionary+AsJson.h"

              void main(){
                NSLog(@"Dictionary as json: %@",
                            [@{ @"A string": @"String!",
                                @"A number": @(20),
                                @"An Array": @[@(1), @(2), @(3)]} asJson]);
              }
            ```

            \begin{figure}[htb]\begin{center}\caption{020\_categories.m part 2}\end{center}\end{figure}
    - "Memory management":
        slides:
          - >
            <% figure("Memory Management circa 1973") do %>
              <%= graphic("1973.jpg", 0.5) %>
            <% end %>
          - >
            C based languages have traditionally used `malloc` and `free` as the means by which memory was allocated on demand. This code looked something like:

            ```c
              #include <stdio.h>
              #include <stdlib.h>

              int main(){
                int * anInteger = malloc(sizeof(int));
                *anInteger = 10;
                printf("Integer value is %i", *anInteger);
                free(anInteger);
                return 0;
              }
            ```
          - >
            `malloc` and `free` allocated memory on the heap; it was the programmer's responsibility to indicate when a particular item was ready to be released back to the operating system.
          - >
            <% figure("Memory Management circa 1983") do %>
              <%= graphic("1983.jpg", 0.5) %>
            <% end %>
          - >
            Objective C used an "easier" means of managing the memory for its objects: reference counting.

            Reference counting allowed Objective C programmers to write code that looked like this:

            ```objectivec
              NSString * c = [[NSString alloc] initWithString:@"This is a string"];
              NSLog(@"String is %@", c);
              [someOtherObject setString:c];
              [c release];
            ```
          - >
            Each object would respond to two methods: `retain` and `release`. Retain would increment an object's retain count, and release would decrement. When an object's retain count reached 0, it was considered "deallocated", and its memory on the heap would be available for use by other objects.
          - >
            Objects could also be flagged as `autorelease`, which would send a release to an object at some point in the future. Typically this meant after one main NSRunLoop cycle (one UI loop).
          - >
            <% figure("Memory Management circa 2006 - Apple adds Garbage Collection to Objective C") do %>
              <%= graphic("2006.jpg", 0.5) %>
            <% end %>
          - >
            <% figure("Memory Management circa 2008 - The iOS SDK 2.0 and App Store launch. The iPhone does not support Garbage Collection due to performance concerns.") do %>
              <%= graphic("2008.jpg", 0.5) %>
            <% end %>
          - >
            <% figure("Memory Management circa 2011 - ARC") do %>
              <%= graphic("2011.jpg", 0.5) %>
            <% end %>
          - >
            Apple introduces a new tool called [ARC](http://en.wikipedia.org/wiki/Automatic_Reference_Counting) (_Automatic Reference Counting_). Improvements in static code analysis allow Apple to detect and automatically insert retain/release calls for most code.

            In other words, _most of the basic memory management is now done for you_.
          - >
            What ARC _will do_ for you:

            * Let you avoid calling `retain` or `release` on Objective C objects


            What ARC __will not do__ for you:

            * Prevent cyclic memory ownership

            * Allow you to ignore `malloc` or `free` when using C-based apis

            * Allow you to totally ignore memory management

          - >
            # Working With Arc

            ```objectivec
              NSString * s = [[NSString alloc] initWithString:@"Some string"];
              NSLog(@"My string is %@", s);
              // That's it.
            ```
          - >
            # Working With Arc

            ```objectivec
              NSString * s = [[NSString alloc] initWithString:@"Some string"];
              [someOtherObject setString:s];

              // and in the someOtherObject's implementation

              @interface SomeOtherObject

              @property(strong,nonatomic) NSString * string;

              @end
            ```
          - >
            # Working With Arc

            Usage of ARC is by default on all new iOS projects. You can choose to disable it and manually manage memory. You can also still manually manage memory created through `malloc` and `free` if necessary.
    - "More learning":
        slides:
          - >
            Objective C is a deep language.  There are lots of resources on the web and your computer where you can learn more. The best is easily the XCode documentation, but there are blogs out there that can provide invaluable help:

            * Mike Ash's [NSBlog](http://www.mikeash.com/pyblog/)

            * [objc.io](http://www.objc.io/)

            * [NSHipster](http://nshipster.com/)

            * [Apple Developer Forums](http://developer.apple.com/devforums/)

  - "iPhone App Basics: UIViewControllers":
    - "MVC, as applied to an app":
        slides:
          - >
            Apple strongly encourages you to adhere to Model View Controller pattern
            <% figure("Model, View and Controller") do %>
              <%= graphic("mvc.jpg", 0.5) %>
            <% end %>
    - "Application \\Rightarrow Window \\Rightarrow View Controller(s) \\Rightarrow View(s) + Models":
        slides:
          - >
            On iOS, a UIApplication ( your app ) typically has one UIWindow, which is the primary UIView upon which everything else displays.  A UIView is "just" a rectangle upon which you draw things.
          - >
            Almost everything visual is a UIView (except the things that aren't).
          - >
            <% figure("UIViews are everything") do %>
              <%= graphic("UIViewExample.pdf", 0.35) %>
            <% end %>
          - >
            <% figure("UIViews are almost everything") do %>
              <%= graphic("UIViewExample2.pdf", 0.35) %>
            <% end %>
          - >
            UIViewControllers are objects that manage what the views on screen are currently doing; typically where you write event handling code, user interaction code, and interact with your models.
          - >
            There is no "official" model object in this pattern. Your business objects are the models, however you decide to implement them.
    - "Storyboards":
        slides:
          - >
            Storyboards let you visualize the interaction between UIViewControllers. You can design both the UIView layout and the interaction between UIViewControllers using the Storyboard designer.
              <% figure("The Storyboard designer") do %>
                <%= graphic("storyboard.jpg", 0.5) %>
              <% end %>
          - >
            Storyboards are comprised of __scenes__ and __segues__. A __scene__ represents a UIViewController's presentation. A __segue__ is the transition between __scenes__, and carry information about the transition origin and destination, as well as the nature of the transition.
    - "Lab 2":
        slides:
          - >
            Create a new "Single View" project
            <% figure("Create a new project") do %>
              <%= graphic("NewProject.png", 0.5) %>
            <% end %>
          - >
            Add a new NSObject subclass of "UIVIewController" to the project named "DetailViewController"
            <% figure("New Objective C class") do %>
              <%= graphic("NewObjectiveCClass.png", 0.5) %>
            <% end %>
            <% figure("Subclassing UIViewController") do %>
              <%= graphic("DetailViewController.png", 0.5) %>
            <% end %>
          - >
            Add a "UIViewController" object from the Object library on to your storyboard.
            <% figure("The UIViewController object in the Library") do %>
              <%= graphic("SelectViewControllerFromLibrary.png", 0.25) %>
            <% end %>
            <% figure("Drop UIViewController on Storyboard") do %>
              <%= graphic("DropViewControllerOnToStoryboard.png", 0.5) %>
            <% end %>
          - >
            Set the subclass of the UIViewController to "DetailViewController".
            <% figure("Setting the UIViewController subclass") do %>
              <%= graphic("ChooseViewControllerSubclass.png", 0.5) %>
            <% end %>
          - >
            Double click on the first UIViewController in the stoyrboard and add a button with the text "Show Detail" to its scene.
            <% figure("Drag a button to the scene") do %>
              <%= graphic("DragButtonToStoryboard.png", 0.5) %>
            <% end %>
          - >
            Select the button, and view its outlets in the inspector pane. Drag from the `action` outlet under `Triggered Segues` to the "Detail View Controller" scene in your storyboard. Choose "Modal" when asked what sort of segue style will be used.
            <% figure("Connect the action to the Detail View Controller") do %>
              <%= graphic("ConnectionActionToDetailController.png", 0.5) %>
            <% end %>
          - >
            Double click on the Detail View Controller and add a button to its scene with the text "Close".
          - >
            Add the following code to `DetailViewController.h`

            ```objectivec
              -(IBAction) dismissDetailView:(id) sender;
            ```
          - >
            Add the following code to `DetailViewController.m`

            ```objectivec
              -(IBAction) dismissDetailView:(id) sender {
                [self dismissViewControllerAnimated:YES completion:nil];
              }
            ```
          - >
            In your Storyboard, select the "Close" button you added to the Detail View Controller, and connect its "Touch Up Inside" outlet to the Detail View Controller. Select the "dismissDetailView:" selector when prompted which selector to connect to.

            <% figure("Connect the action to the dismiss selector") do %>
              <%= graphic("ConnectToDismissSelector.png", 0.5) %>
            <% end %>
          - >
            Run the project!

            <% figure("Yay, it works!") do %>
              <%= graphic("yay.jpg", 0.5) %>
            <% end %>
          - >
            _One more thing_: Add another button on the Detail View controller that opens another View Controller as a modal, and this new view controller has a button on it that when tapped opens an alert box that says "Hello World".
    - "UINavigationController":
        slides:
          - >
            UINavigationController is a stack based manager of view controllers that the user can navigate through. The tiny left-facing back arrow present in most iOS apps is its most obvious characteristic.

            <% figure("UINavigationController at work") do %>
              <%= graphic("UINavigationControllerInAction.png", 0.5) %>
            <% end %>
          - >
            <% figure("Items managed by UINavigationController ") do %>
              <%= graphic("UIViewExample3.pdf", 0.35) %>
            <% end %>
          - >
            Every UIViewController managed by a UINavigationController has a reference to that UINavigationController in `[self navigationController]`.

            ```objectivec
              -(void) viewDidLoad {
                [super viewDidLoad];
                NSLog(@"There are currently %i controllers in the navigation stack",
                        self.navigationController.childViewControllers.count);
              }
            ```
          - >
            You can add another UIViewController to the navigation stack by using the `push` segue when connecting view controllers in Storyboard.

            <% figure("Selecting the push segue") do %>
              <%= graphic("SelectPushSegue.png", 0.5) %>
            <% end %>

            _Note:_ This segue will only work if you've already set up a UINavigationController, it will not automatically create a UINavigationController for you.
          - >
            You can also push UIViewControllers on the stack manually.

            ```objectivec
              MyViewController * controller = [[MyViewController alloc] initWithNibName:nil
                                                                        bundle:nil];
              [[self navigationController] pushViewController:controller animated:YES];
            ```
    - "Lab 3":
        slides:
          - >
            Create a new "Single View" project
            <% figure("Create a new project") do %>
              <%= graphic("NewProject.png", 0.5) %>
            <% end %>
          - >
            Open the project's storyboard and add a new "UINavigationController" to the storyboard.
            <% figure("Select UINavigationController in the Object library") do %>
              <%= graphic("UINavigationControllerInLibrary.png", 0.5) %>
            <% end %>
          - >
            Drag the storyboard's "initial scene" arrow from the default view controller scene to the UINavigationController you placed.
            <% figure("Drag the initial scene arrow to the UINavigationController") do %>
              <%= graphic("DragInitialSceneArrow.png", 0.25) %>
            <% end %>
          - >
            Drag the "root view controller" outlet from the UINavigationController to the default view controller in the storyboard.
            <% figure("Change the root view controller outlet") do %>
              <%= graphic("ChangeRootViewController.png", 0.25) %>
            <% end %>
          - >
            Add a new NSObject subclass of "UIVIewController" to the project named "DetailViewController"
            <% figure("New Objective C class") do %>
              <%= graphic("NewObjectiveCClass.png", 0.5) %>
            <% end %>
            <% figure("Subclassing UIViewController") do %>
              <%= graphic("DetailViewController.png", 0.5) %>
            <% end %>
          - >
            Add a "UIViewController" object from the Object library on to your storyboard.
            <% figure("The UIViewController object in the Library") do %>
              <%= graphic("SelectViewControllerFromLibrary.png", 0.25) %>
            <% end %>
            <% figure("Drop UIViewController on Storyboard") do %>
              <%= graphic("DropViewControllerOnToStoryboard.png", 0.5) %>
            <% end %>
          - >
            Set the subclass of the UIViewController to "DetailViewController".
            <% figure("Setting the UIViewController subclass") do %>
              <%= graphic("ChooseViewControllerSubclass.png", 0.5) %>
            <% end %>
          - >
            Double click on the first UIViewController in the stoyrboard and add a button with the text "Show Detail" to its scene.
            <% figure("Drag a button to the scene") do %>
              <%= graphic("DragButtonToStoryboard.png", 0.5) %>
            <% end %>
          - >
            Select the button, and view its outlets in the inspector pane. Drag from the `action` outlet under `Triggered Segues` to the "Detail View Controller" scene in your storyboard. Choose "Push" when asked what sort of segue style will be used.
            <% figure("Connect the action to the Detail View Controller") do %>
              <%= graphic("ConnectionActionToDetailController.png", 0.5) %>
            <% end %>
          - >
            Double click on the Detail View Controller and add a label to its scene with the text "Valuable Detail".
            <% figure("Select and place the Label control") do %>
              <%= graphic("SelectLabelControl.png", 0.5) %>
            <% end %>
          - >
            Select the navigation bar in the detail view controller, and change its title attribute to "My Detail View".
            <% figure("Select UINavigationItem in controller") do %>
              <%= graphic("SelectUINavigationItem.png", 0.5) %>
            <% end %>
            <% figure("Change UINavigationItem title") do %>
              <%= graphic("ChangeUINavigationItemTitle.png", 0.5) %>
            <% end %>
          - >
            Run the app!
            <% figure("Put it on the App Store!") do %>
              <%= graphic("distinguishedyay.jpg", 0.5) %>
            <% end %>
          - >
            _One more thing_: Add a button on your Detail View Controller that opens up a new View Controller that shows an image.
    - "UITabBarController":
        slides:
          - >
            A UITabBar is the control that sits at the bottom of a screen, and allows you to switch between different views based on the button you click.

            <% figure("UITabBar examples") do %>
              <%= graphic("tabbar.png", 0.25) %>
            <% end %>
          - >
            A UITabBarController swaps in UIViewControllers assigned to it when users click on the associated button
          - >
            Each UIViewController has a tabBarItem property that UITabBarController uses to populate its UITabBar
          - >
            <% figure("UITabBarController example") do %>
              <%= graphic("UIViewExample4.pdf", 0.30) %>
            <% end %>
          - >
            <% figure("Sir Not Appearing In This Class") do %>
              <%= graphic("sir.jpg", 0.35) %>
            <% end %>
    - "UITableViewController":
          - >
            UITableViews make up the majority of navigational aids in most iOS apps. If you see a vertical list of selectable items, it is almost certainly a UITableView.

            <% figure("UITableView examples") do %>
              <%= graphic("tableview.png", 0.35) %>
            <% end %>
          - >
            A UITableView presents data in two dimensions: __sections__ and __rows__. For any section __N__, there may be __M__ rows of information to present.
          - >
            Each cell in a UITableView is represented by a UITableViewCell. A UITableViewCell in its default implementation allows for a title label, a left aligned image view, and an optional accessory view that is right aligned.

            <% figure("UITableViewCell default style") do %>
              <%= graphic("UITableViewCell.png", 0.35) %>
            <% end %>
          - >
            A UITableView has special code that allows it to only create as many UITableViewCells as are currently on the screen, as opposed to the number of rows in your source data.  This allows you to easily support paging through many thousands of items w/ negligible performance impact.
          - >
            A UITableViewController has many pre-filled methods to make interacting with UITableViews easier. It is a subclass of UIViewController, and is merely a convenience to the programmer.

            <% figure("UITableView example") do %>
              <%= graphic("UIViewExample5.pdf", 0.30) %>
            <% end %>
    - "Lab 4":
        slides:
          - >
            Create a new "Single View" project
            <% figure("Create a new project") do %>
              <%= graphic("NewProject.png", 0.5) %>
            <% end %>
          - >
            Open the project's storyboard and add a new "UINavigationController" to the storyboard.
            <% figure("Select UINavigationController in the Object library") do %>
              <%= graphic("UINavigationControllerInLibrary.png", 0.5) %>
            <% end %>
          - >
            Drag the storyboard's "initial scene" arrow from the default view controller scene to the UINavigationController you placed.
            <% figure("Drag the initial scene arrow to the UINavigationController") do %>
              <%= graphic("DragInitialSceneArrow.png", 0.25) %>
            <% end %>
          - >
            Add a new subclass of NSObject to your project that is a subclass of "UITableViewController".

            <% figure("Add a new subclass of UITableViewController") do %>
              <%= graphic("NewSubclassOfUITableViewController.png", 0.5) %>
            <% end %>
          - >
            Change the subclass of the UITableViewController connected to your UINavigationController in Storyboard to the UITableViewController you created.

            <% figure("Change subclass to new UITableViewController") do %>
              <%= graphic("ChangeSubclassToTableViewController.png", 0.5) %>
            <% end %>
          - >
            Add the following code to PCTableViewController.h:

            ```objectivec
              @property NSArray * items;
            ```

            Add the following code to PCTableViewController.m:

            ```objectivec
              -(void) viewDidLoad {
                [super viewDidLoad];
                self.items = @[@"One", @"Two", @"Three"];
              }
            ```
          - >
            Change the method `numberOfSectionsInTableView:(UITableView *) tableView` in PCTableViewController.m to return 1.
          - >
            Change the method `tableView:(UITableView *) tableView cellForRowAtIndexPath:(NSIndexPath *) path` to return `self.items.count`.
          - >
            Change the method `tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath` to:

            ```objectivec
              UITableViewCell *cell = [tableView
                 dequeueReusableCellWithIdentifier:@"DefaultCell"
                                      forIndexPath:indexPath];

              cell.textLabel.text = [self.items objectAtIndex:indexPath.row];

              return cell;
            ```
          - >
            Double click on the table view controller in Storyboard and select the prototype UITableViewCell. Change its reuse identifier to "DefaultCell".

            <% figure("Change Reuse Identifier") do %>
              <%= graphic("ChangeReuseIdentifier.png", 0.5) %>
            <% end %>
          - >
            In the `PCViewController.h`, add the following code.

            ```objectivec
              @property NSString * name;
              @property IBOutlet UILabel * nameLabel;
            ```
          - >
            In Storyboard, drag a UILabel to PCViewController and connect it to the nameLabel outlet.

            <% figure("Connect the UILabel to the nameLabel outlet") do %>
              <%= graphic("ConnectLabelToOutlet.png", 0.5) %>
            <% end %>
          - >
            In PCViewController.m, add the following code:

            ```objectivec
              -(void) viewDidLoad {
                [super viewDidLoad];
                self.nameLabel.text = [NSString stringWithFormat:@"Name: %@", self.name];
              }
            ```
          - >
            In Storyboard, select the prototype cell in the table view controller and connect its "selection" triggered segue to the PCViewController and choose "Push".

            <% figure("Connect the selection segue of the UITableViewCell") do %>
              <%= graphic("ConnectSelectionSegue.png", 0.5) %>
            <% end %>
          - >
            In PCTableViewController.m, uncomment the method `prepareForSegue:sender:` and add the following code:

            ```objectivec
              PCViewController * c = (PCViewController *)[segue destinationViewController];
              c.name = [self.items objectAtIndex:self.tableView.indexPathForSelectedRow.row];
            ```

            Add the following line to the top of the file:

            ```objectivec
              #import "PCViewController.h"
            ```
          - >
            Run it!
            <% figure("Time to get pumped") do %>
              <%= graphic("hulk.jpg", 0.5) %>
            <% end %>
          - >
            _One more thing_: Add a JSON file to your project that is an array of items. Deserialize it in your UITableViewController, and use the information from the JSON file to populate your UITableView and UIViewController.
    - "An Aside: The Delegate Pattern":
        - >
          You may have noticed that UITableViewController had odd methods like `- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section`. Why does the UITableViewController need to have a UITableView passed to its numberOfRowsInsection method?
        - >
          The delegate pattern allows for a weak binding between two objects, such that a "delegate" can be queried for configuration information and special behavior from an acting object.
        - >
          Objective C formal protocols are typically how a delegate can indicate at compile time that it provides certain functionality. See UITableViewDelegate and UITableViewDataSource.
        - >
          The delegate pattern is used widely throughout Apple frameworks.

          <% figure("Delegate usage throughout the documentation") do %>
            <%= graphic("DelegateGrep.png", 0.5) %>
          <% end %>
    - "Review Concepts: UIViewController Basics":
        - >
          Build an iOS app that:

          * Has a UINavigationController

          * Loads a UITableViewController as its first scene

          * Populates the UITableViewController rows names taken from a JSON file in the local file system

          * Populates the UITableViewController rows with images specified from the JSON file

          * When a table row is selected, loads a detail view controller that presents the name and image that the user selected
    - "HTTP Requests - Networking":
      - "NSURL, NSURLRequest,  NSMutableURLRequest AND NSURLConnection":
          slides:
            - >
              NSURL is meant to only represent a single resource location

              ```objectivec
                NSURL * theUrl = [NSURL URLWithString:@"http://bootstrapping-ios.com/"];
              ```
            - >
              NSURL can be allocated to represent either a filesystem location, or a web resource

              ```objectivec
                NSURL * aWebUrl = [NSURL URLWithString:@"http://news.ycombinator.org/"];
                NSURL * aFileUrl = [NSURL fileURLWithPath:[[NSBundle mainBundle] pathForResource:@"index" ofType:@"json"]]];
              ```
            - >
              NSURLRequest and NSMutableURLRequest represent specific web resources that you'd like to initiate a connection to; NSURLRequest should be used for simple GET HTTP requests,while NSMutableURLRequests can be used for more complex HTTP requests (POST, PUT, file uploads).
            - >
              NSMutableURLRequest allows you to set HTTP headers, the HTTP method used, and the request body.
            - >
              ```objectivec
                NSURLRequest * request = [NSURLRequest requestWithURL:[NSURL URLWithString:@"http://bootstrapping-ios.com/"]];

                NSMutableURLRequest *  customRequest = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"http://bootstrapping-ios.com/"]];
                [customRequest setHTTPMethod:@"POST"];
                [customRequest setValue:@"Some-Token" forHTTPHeaderField:@"X-Request-Token"];
                [customRequest setValue:@"multipart/form-data" forHTTPHeaderField:@"Content-Type"];
                [customRequest setHTTPBody:[@"some-form=values" dataUsingEncoding:NSUTF8StringEncoding]];
              ```
            - >
              NSURLConnection can send data both synchronously or asynchronously. Asynchronous response information is passed back to the connection delegate via the NSURLConnectionDelegate, NSURLConnectionDataDelegate and NSURLConnectionDownloadDelegate protocols.
            - >
              NSURLConnection initiates the download and returns the NSHTTPURLResponse which contains the body of the response, as well as http status code and response headers.

              ```objectivec
                NSURLRequest * request = [NSURLRequest requestWithURL:[NSURL URLWithString:@"http://bootstrapping-ios.com/"]];

                NSError * error;
                NSHTTPURLResponse * response;
                NSData * syncResponse = [NSURLConnection sendSynchronousRequest:request
                  returningResponse:&response
                  error:&error];

                NSURLConnection * asyncConnection = [[NSURLConnection alloc] initWithRequest:request
                  delegate:self
                  startImmediately:YES];
              ```
            - >
              NSURLSession adds conveniences for downloading content in the backgroun.
      - "Lab 5":
          slides:
              - >
                Create a new "Single View" project
                <% figure("Create a new project") do %>
                  <%= graphic("NewProject.png", 0.5) %>
                <% end %>
              - >
                Open the project's storyboard and add a new "UINavigationController" to the storyboard.
                <% figure("Select UINavigationController in the Object library") do %>
                  <%= graphic("UINavigationControllerInLibrary.png", 0.5) %>
                <% end %>
              - >
                Drag the storyboard's "initial scene" arrow from the default view controller scene to the UINavigationController you placed.
                <% figure("Drag the initial scene arrow to the UINavigationController") do %>
                  <%= graphic("DragInitialSceneArrow.png", 0.25) %>
                <% end %>
              - >
                Add a new subclass of NSObject to your project that is a subclass of "UITableViewController".

                <% figure("Add a new subclass of UITableViewController") do %>
                  <%= graphic("NewSubclassOfUITableViewController.png", 0.5) %>
                <% end %>
              - >
                Change the subclass of the UITableViewController connected to your UINavigationController in Storyboard to the UITableViewController you created.

                <% figure("Change subclass to new UITableViewController") do %>
                  <%= graphic("ChangeSubclassToTableViewController.png", 0.5) %>
                <% end %>
              - >
                In the `viewDidLoad` method of your `UITableViewController`, initialize a request to the URL:

                `http://bootstrapping-ios.com/echo?names=one&names=two&names=three`

                Using NSURLConnection, asynchronously request the above JSON, deserialize it into an NSArray, and then reload your tableview.
              - >
                You will need to have your view controller adopt specific methods from the NSURLConnectionDelegate and  NSURLConnectionDataDelegate protocols. You will also need to store the request data in something like NSMutableData.
              - >
                Run the app!
                <% figure("Basically an expert") do %>
                  <%= graphic("distinguishedyay.jpg", 0.5) %>
                <% end %>
              - >
                _One more thing_: Change your request to a POST request with `application/x-www-form-urlencoded` content type, and instead of sending a querystring in the URL, send the key value pairs in the HTTP body.
              - >
                _And another thing_: Select your TableViewController and enable "Refreshing" in its attributes. Connect the UIRefreshControl's Value Changed outlet to an IBAction method on your TableViewController that triggers a new download. Tell the refresh control to change its appearance through `[self.refreshControl beginRefreshing]` and `[self.refreshControl endRefreshing]`.

