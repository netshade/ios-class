presentations:
- subtitle: ""
  title: "Bootstrapping iOS Application Development"
  author: "Chris Zelenak"
  date: "12/02/2013"
  sections:
  - "Intro to class":
      slides:
        - >
          Welcome to the 5-Day Bootstrapping iOS Application Development class. Over the course of these next 5 days, we're going to be reviewing Objective C, UIKit, Core Animation, Core Data, and a host of other technologies you may only know by name.
  - "Lab 1":
    - "Create a new iPhone Project":
        slides:
          - >
            Create a new Single View based application in XCode called Lab1 \menu{File > New > Project}

            <% figure("New Projects") do %>
              <%= graphic("NewProject.png", 0.5) %>
            <% end %>
          - >
            Open Main.storyboard in Interface Builder

            <% figure("Main Storyboard") do %>
              <%= graphic("MainStoryboard.png", 0.5) %>
            <% end %>
    - "Add a button":
        slides:
          - >
            Add a button with the text "Hello iPhone"

            <% figure("Drag Button to Storyboard") do %>
              <%= graphic("DragButtonToStoryboard.png", 0.5) %>
            <% end %>
    - "Connect the button to the view controller":
        slides:
          - >
            Add an IBAction selector to the view controller

            ```objectivec
              // In the ViewController.h file
              -(IBAction) helloWorldTapped:(id)sender;
            ```
          - >
            Make it open an alert view

            ```objectivec
              // In the ViewController.m file
              -(IBAction) helloWorldTapped:(id)sender {
                  [[[UIAlertView alloc] initWithTitle:@"Yay it worked"
                                              message:@"Hello World"
                                             delegate:nil
                                    cancelButtonTitle:@"Dismiss"
                                    otherButtonTitles: nil] show];
              }
            ```
          - >
            Connect the `IBAction` to the Button's `Touch Up Inside` action.

            <% figure("Connect Touch Up Inside event to IBAction") do %>
              <%= graphic("ConnectTouchUpToHelloWorld.png", 0.5) %>
            <% end %>
    - "Build and run in simulator":
        slides:
          - >
            Run the simulator with \keys{\cmd + R}, the \menu{Product > Run} menu, or the Play button

            <% figure("Launch Simulator") do %>
              <%= graphic("LaunchInSimulator.png", 0.5) %>
            <% end %>
          - >
            <% figure("It Worked!") do %>
              <%= graphic("YayItWorked.png", 0.5) %>
            <% end %>
  - "Objective C":
    - "Overview":
        slides:
          - >
            Objective C is a superset of C. It tacks on to C a message-passing object model similar to Smalltalk's (see Ruby), with support for reflection and limited runtime dynamic programming.
          - >
            Objective C allows you to use weak and dynamicly typed language features along with the static typing of C; it also allows you to take advantage of runtime method resolution, so that your object's implementation of certain messages may be determined at call-time rather than at compile-time.
          - >
            The language is still physically identical to C in many ways, in that the bulk of your development will be alternating between header files (.h files) and implementation files (.m files). You will also be doing a lot of memory management, which may fill you with either fear or joy, depending on your experience with garbage collected languages.
          - >
            You will also be dealing a lot with many other C-family familiars, such as enumerated integer constants (enums), structs, pass-by-reference v. pass-by-value semantics and pointers.  You don't need to have a very strong grasp on these things immediately, but the more iPhone programming and Objective C programming you do, the more your skills will benefit from a firm grasp of C.
        notes: |
          Objective C is a language similar in many ways to Smalltalk or Ruby. This similarity lies primarily in its object system; objects receive "messages", and may respond to them through statically known methods or runtime selected methods.
          What many people refer to as "Objective C" is actually the various Cocoa family frameworks that Apple has provided, and enhancements to the tooling infrastructure. You could think of Apple's frameworks as the _Standard Library_ of Objective C, much like Ruby or C++'s  standard library.
    - "Review of standard C elements":
        slides:
          - >
            # Variables

            Variable declaration in C follows the form `TYPE_DESCRIPTION NAME`, eg:

            ```c
              int i = -1; // just an integer
              unsigned int k = 0; // an unsigned integer
              const unsigned int j = 0; // a constant unsigned integer, no reassignment
              const char c = 'c'; // a constant char
              const char * s = "a constant string"; // a read only pointer to a char array
            ```

            \begin{figure}[htb]\begin{center}\caption{001\_variables.c}\end{center}\end{figure}
          - >
            These are items you'll commonly encouter while doing iPhone programming whose roots belong in the C family:

            ```c
              typedef enum {
                NONE = 0,
                SOME,
                ALL
              } HowMany;

              HowMany i = SOME; // Use of enumerated constant
            ```

            \begin{figure}[htb]\begin{center}\caption{002\_enumerations.c}\end{center}\end{figure}

            Note the `typedef` in this example, which is creating a type alias to be used later.
          - >
            # Structs

            ```c
              // Declaring a point in space type
              typedef struct {
                float x;
                float y;
              } APointInSpace;

              APointInSpace point;
              point.x = 20.0;
              point.y = 410.0;

              // C99 style struct instantiation
              APointInSpace point2 = { .x= 21.0, .y=32.0 };
            ```

            \begin{figure}[htb]\begin{center}\caption{003\_typedef.c}\end{center}\end{figure}
          - >
            # Arrays and Pointers

            ```c
              #include <stddef.h>

              // a constant byte array
              char * constantCharArray = "Or in other words, a string";

              // C99 style array instantiation
              int aListOfNumbers[5] = { 1, 2, 3, 4, 5 };
              int aListOfNumbers2[] = { 1, 2, 3, 4, 5};

              // C99 Variable length array declaration
              int someLength = 5;
              float aListOfFloats[someLength];

              // pointer declaration to NULL
              int * someIntegerPtr = NULL;
              int someInteger = 5;

              // address dereference
              someIntegerPtr = &someInteger;
            ```

            \begin{figure}[htb]\begin{center}\caption{004\_arrays\_and\_pointers.c}\end{center}\end{figure}
          - >
            # Functions and Function Pointers

            ```c
              float aSimpleAdditionMethod(float a, float b){
                return a + b;
              }

              float aSimpleSubtractionMethod(float a, float b){
                return a - b;
              }

              int aFloatAdditionThatReturnsAnInt(float a, float b){
                return (int) (a + b);
              }

              float (*anFnPtr)(float, float) = aSimpleAdditionMethod;
              anFnPtr(1, 1); // returns 2
              anFnPtr = aSimpleSubtractionMethod;
              anFnPtr(1, 1); // returns 0
            ```

            \begin{figure}[htb]\begin{center}\caption{005\_functions.c}\end{center}\end{figure}
          - >
            # Preprocessor Statements

            ```c
              #include <stdio.h>
              #define FOO 1
              #define IS_ZERO(n) (n == 0)

              int main(){
                printf("FOO is %i\n", FOO);
                if(IS_ZERO(0)) {
                  printf("This code is very useful.\n");
                }
              }
            ```

            \begin{figure}[htb]\begin{center}\caption{006\_preprocessor.c}\end{center}\end{figure}
          - >
            If you never learned C or it's been a long time, a fantastic book for you is ["The C Programming Language"](http://www.amazon.com/C-Programming-Language-2nd-Edition-ebook/dp/B009ZUZ9FW/ref=dp_kinw_strp_1). It doesn't cover many of the newer items in [C99](http://en.wikipedia.org/wiki/C99), but it is a thorough reference to the language fundamentals.

            If you'd like to read more about the new features introduced by C99, read more at [C99Changes](http://home.datacomm.ch/t_wolf/tw/c/c9x_changes.html).
        notes: |
          While it would be disinegenuous to say that C is "easy", its syntax is simple to learn. The underlying concepts and dearth of a 'modern' standard library is where a large part of the perceived difficulty may lie.
          It is important to realize that through the course of your career writing Objective C, a large part of the code and concepts you will be using come from the C world; in reality they are not unique to C at all, but are a closer representation to how a computer models memory and computation.
          An effective way to think about C is as a high level portable assembler; while the output is not portable to different architectures, the source may be cross compiled in a cross platform manner. ( With the understanding that you did not add any platform specificity to your code. :) )
    - "Syntax":
        slides: >
          # Some typical Objective C code

          ```objectivec
            NSString * anExampleString = @"This is a pointer to an NSString object";
            int strLen = [anExampleString length];

            NSString * aSecondString = [anExampleString
              stringByAppendingString:@" that had a second string appended to it"];

            if([anExampleString
                 compare:@"this is a pointer to an nsstring object"
                 options:NSCaseInsensitiveCompare] == NSOrderedSame){
              NSLog(@"The string %@ was case insensitive equal", anExampleString);
            }
          ```

          \begin{figure}[htb]\begin{center}\caption{007\_basic\_objc\_example.m}\end{center}\end{figure}
    - "Calling functions":
        slides:
          - >
            Given some Objective C object, like:

            ```objectivec
              NSString * anObject = @"TheObject";
            ```

            you can invoke functionality on that object via the form:

            ```objectivec
             [anObject theMethodName];
            ```

            Method names in Objective C follow the form `initialMethodNameAndArgument:theSecondArgument:theThirdArgument:` .
          - >
            # Method calling behavior

            When you see references to "calling a method" or "calling a function" on an object in Objective C, it's best to consider these synonymous with "dispatching a message". Objective C objects respond to __messages__, and as you work more with Objective C, it will be more beneficial for you to perceive this as such.
    - "nil, NULL":
        slides: >
          An object in Objective C may be nil; nil is a "special" object which may have any message at all sent to it, to which it will respond with a nil object.

          ```objectivec
            NSString * anObject = nil;
            if([anObject whoaThisProbablyDoesntExist] == nil){
              NSLog(@"Ah well");
            }
          ```

          \begin{figure}[htb]\begin{center}\caption{008\_calling\_methods\_on\_nil.m}\end{center}\end{figure}

          nil is the appropriate null object when dealing with pointers to Objective C classes; NULL, on the other hand, is the appropriate null value to use when dealing with pointers to all other types.
        notes: |
          Of course, there is also the unfortunately necessary NSNull object, which pops up in cases where the framework needs to formally recognize a deserialized NULL value (see Property Lists, JSON, etc.). You can test if an object is an NSNull object by comparing it `[NSNull null]`.
    - "Initializing objects":
        slides:
          - >
            To initialize an Objective C object, you allocate its memory first with the `alloc` method, then initialize it with an init constructor.

            ```objectivec
              [[SomeClass alloc] init]
            ```
          - >
            Objects may have several different constructors. Each may require different arguments:

            ```objectivec
              [[NSString alloc] initWithString:@"A test string"];
              [[UIView alloc] initWithFrame:CGRectMake(0., 0., 20., 20.)];
            ```
    - "Basic Types":
        slides:
          - >
            There are a host of useful classes in the Cocoa Touch framework that provide special functionality to you.  Some of the more common objects you'll use in your programming are NSArray, NSDictionary, NSNumber and NSString.  Each of these objects have mutable versions that allow you to modify them after instantiation.
          - >
            # The id type

            The special type `id` refers to any valid NSObject or its subclass. You can use the `id` type when you're not sure what sort of object you may be given.
          - >
            # NSString usage

            NSString is an enhanced, unicode aware string class that goes far beyond the simple byte-array behavior of C's byte-array strings.

            ```objectivec
              NSString * s = @"This is an NSString";
              NSMutableString * so = [[NSMutableString alloc]
                                              initWithString:@"This is a mutable string"];

              [so appendString:s];

              NSLog(@"The mutable string is %@", so);
            ```

            \begin{figure}[htb]\begin{center}\caption{008\_nsstring\_example.m}\end{center}\end{figure}
          - >
            # NSNumber usage

            NSNumber is a simple abstract wrapper around numeric values which allows you to automatically convert its held value to the appropriate form, as well as having an object-like representations of a numeric value.

            ```objectivec
              NSNumber * n = @(20.0f);
              double d = [n doubleValue];
              int i = [n intValue];
              NSNumber * b = @(YES);
              NSLog(@"Number is %@, double value is %f, int value is %i", n, d, i);
              NSLog(@"Boolean number is %@, bool value is %i", b, [b boolValue]);
            ```

            \begin{figure}[htb]\begin{center}\caption{009\_nsnumber\_example.m}\end{center}\end{figure}
          - >
            NSDictionary is a generic dictionary object that you can use to hold key/value associations. A key can be any NSObject that responds to isEqual: and NSCopying; in most cases, your keys will be either NSString or NSNumber objects.
          - >
            # NSDictionary usage

            ```objectivec
              NSDictionary * a = @{
                @"Foo": @"The Foo string",
                @"Bar": @"The Bar string"
              };

              NSMutableDictionary * b = [[NSMutableDictionary alloc] init];
              [b setObject:@"Another string" forKey:@(20)];

              NSLog(@"a's value for Foo is %@, and b's value for 20 is %@",
                                        [a objectForKey:@"Foo"],
                                        [b objectForKey:@(20)]);

              for(id key in a){
                NSLog(@"The value for %@ is %@", key, [a objectForKey:key]);
              }
            ```

            \begin{figure}[htb]\begin{center}\caption{010\_nsdictionary\_example.m}\end{center}\end{figure}
          - >
            # NSArray usage

            NSArray is a simple way to collect NSObject inheriting classes into a sequential list.  NSArray automatically retains each object added to it, and releases each object it holds once its own retain count has reached 0.

            ```objectivec
              NSArray * a = @[@"Foo", @"bar", @"baz"];
              NSMutableArray * b = [[NSMutableArray alloc] init];
              [b addObject:@"Not foo"];
              NSLog(@"The contents of a are %@ and b are %@", a, b);

              for(id obj in a){
                NSLog(@"The array contains %@", obj);
              }
            ```

            \begin{figure}[htb]\begin{center}\caption{011\_nsarray\_example.m}\end{center}\end{figure}
          - >
            NSArray, NSDictionary, NSString and NSNumber may all be represented by the contents of a property list file ( Plist ).  You can easily rebuild an NSArray or NSDictionary full of the property list contents by using the initialization method `initWithContentsOfFile:`
          - >
            # Property List Deserialization

            <% figure("Sample Property List") do %>
              <%= graphic("PListExample1.png", 0.5) %>
            <% end %>

            ```objectivec
              NSDictionary * example = [[NSDictionary alloc]
                                           initWithContentsOfFile:@"/path/to/sample.plist"];
              NSLog(@"The subarray contents are %@",
                         [example objectForKey:"A subarray of values"]);
            ```

            \begin{figure}[htb]\begin{center}\caption{012\_plist\_example.m}\end{center}\end{figure}
          - >
            Apple also provides JSON serialize/deserialize capability in the `NSJSONSerialization` class. This class can decode NSString, NSNumber, NSArray and NSDictionary values much like property lists.

            ```objectivec
              NSDictionary * dict = @{ @"foo": @"bar" };
              NSData * jsonData = [NSJSONSerialization dataWithJSONObject:dict
                                                                  options:0
                                                                    error:nil];
              if([jsonData writeToFile:@"./test.json" atomically:YES]){
                NSData * inputJsonData = [NSData dataWithContentsOfFile:@"./test.json"];
                id jsonDict = [NSJSONSerialization JSONObjectWithData:inputJsonData
                                                                options:0
                                                                  error:&error];
                NSLog(@"Foo's value is %@", [jsonDict objectForKey:@"foo"]);
              }
            ```

            \begin{figure}[htb]\begin{center}\caption{013\_json\_example.m}\end{center}\end{figure}
    - "Classes":
        slides:
          - >
            # Class interface declaration

            Classes in Objective C are similar to their C++ cousins in that they come in two parts: interface declaration and implementation. The interface declaration portion of a class follows the form:


            ```objectivec
              #import <Foundation/Foundation.h>
              @interface MyNewClass : NSObject {
                int privateVariable1;
                NSString * privateVariable2;
              }

              +(int) someClassMethod;
              -(void) doSomething;
              -(NSString *) giveMeAStringOfLength:(int)length
                                randomizeContents:(BOOL)randomize;
              @end
            ```

            \begin{figure}[htb]\begin{center}\caption{014\_objects.m part 1}\end{center}\end{figure}
          - >
            # Class implementation

            The implementation of this class follows the form:

            ```objectivec
              #import "MyNewClass.h"

              @implementation MyNewClass

              -(id) init {
                self = [super init];
                if(self){
                  privateVariable1 = 20;
                  privateVariable2 = [[NSString alloc] initWithString:@"Test"];
                }
                return self;
              }

              +(int) someClassMethod {
                return 0;
              }

            ```

            \begin{figure}[htb]\begin{center}\caption{014\_objects.m part 2}\end{center}\end{figure}
          - >
            # Class implementation pt. 2

            ```objectivec
              -(void) doSomething {
                NSLog(@"Something");
              }

              -(NSString *) giveMeAStringOfLength:(int)length
                                randomizeContents:(BOOL)randomize {
                return @"TODO: Make work";
              }

              @end
            ```

            \begin{figure}[htb]\begin{center}\caption{014\_objects.m part 3}\end{center}\end{figure}
    - "Properties":
        slides:
          - >
            Much of the interaction with Objective C objects equates to the usual getter/setter functionality commonly associated with Object Oriented Programming. To make it easier for programmers to declare this functionality, properties were introduced as a way to eschew all the boilerplate code and provide a common framework upon which to enhance Objective C objects.
          - >
            # Property interface declaration

            ```objectivec
              @interface MyObject : NSObject {

              }
              @property(strong) NSString * instanceVariable;
              @property float numericVariable;
              @end

              @implementation MyObject

              @end
            ```

            \begin{figure}[htb]\begin{center}\caption{015\_properties.m part 1}\end{center}\end{figure}
          - >
            # Property usage

            ```objectivec
              MyObject * mo = [[MyObject alloc] init];

              // Bracket Syntax
              [mo setInstanceVariable:@"Test"];
              [mo setNumericVariable:20.0f];
              NSLog(@"The values I set were %@ and %f",
                      [mo instanceVariable],
                      [mo numericVariable]);

              // Dot Syntax
              mo.instanceVariable = @"Test 2";
              mo.numericVariable = 25.0f;
              NSLog(@"The values I set were %@ and %f",
                      mo.instanceVariable,
                      mo.numericVariable);
            ```

            \begin{figure}[htb]\begin{center}\caption{015\_properties.m part 2}\end{center}\end{figure}
          - >
            You can specify the memory management semantics (strong, weak, copy), atomicity (locking behavior), and access level in the property declaration. You can also specify your own implementation of the getter and setter methods.

            ```objectivec
              @property(readonly) NSString * privateName;
              @property(weak, nonatomic, setter=myAgeSetter:) NSNumber * age;
            ```

            \begin{figure}[htb]\begin{center}\caption{016\_advanced\_properties.m}\end{center}\end{figure}
          - >
            # Key Value Observing

            Properties do not merely provide getter/setter functionality.  The use of properties also implicitly adds Key-Value-Observing functionality to your class, letting you automatically monitor classes for change events and performing specific code in such cases.  Read more in the [SDK Documentation on properties](https://developer.apple.com/library/mac/documentation/cocoa/conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html) and [Key Value Observing](https://developer.apple.com/library/mac/documentation/cocoa/conceptual/KeyValueCoding/Articles/KeyValueCoding.html#//apple_ref/doc/uid/10000107i).
    - "Selectors":
        slides:
          - >
            Selectors in Objective C are a way to indicate a message as a variable. They allow you to dynamically send a message to an object, as well as to query an object to see if it responds to a given message.
          - >
            # Selector usage

            ```objectivec
              SEL aSelector = @selector(length);
              NSString * foo = @"Foo";
              if([foo respondsToSelector:aSelector]){
                NSLog(@"The length of foo is %i",  [foo performSelector:aSelector]);
              }
            ```

            \begin{figure}[htb]\begin{center}\caption{017\_selectors.m}\end{center}\end{figure}
          - >
            # Other selector usage

            Selectors can be built from strings, and can refer to any Objective C message that is forwarded to an object.

            ```objectivec
              NSString * anAllCapsString = @"THIS STRING SHOULD BE LOWERCASE";
              NSString * theMessageToSend = @"lowercaseString";
              SEL aSelector = NSSelectorFromString(theMessageToSend);
              if([anAllCapsString respondsToSelector:aSelector]){
                NSLog(@"All caps string (%@) converted: %@",
                            anAllCapsString,
                            [anAllCapsString performSelector:aSelector]);
              }
            ```

            \begin{figure}[htb]\begin{center}\caption{018\_advanced\_selectors.m}\end{center}\end{figure}
    - "Protocols":
        slides:
          - >
            Objective C provides only single-inheritance for its objects; to allow for situations where a class may provide functionality outside of its inheritance chain, the language provides Protocols, which are roughly analogous to interfaces in Java and C#.  There are informal protocols (only referred to in documentation) and formal protocols, which are compiler checked.  The majority of protocol usage in iOS programming is formal protocols.
          - >
            # Protocol declaration

            ```objectivec
              @protocol CameraDevice

              -(NSString *) manufacturerName;

              @optional

              -(int) flashStrength;

              @end

              @interface AnExpensiveCanonCamera : NSObject<CameraDevice>
              @end

              @interface TheCheapestCameraEver : NSObject<CameraDevice>
              @end
            ```

            \begin{figure}[htb]\begin{center}\caption{019\_protocols.m part 1}\end{center}\end{figure}
          - >
            # Protocol usage

            ```objectivec
              NSArray * cameras = @[
                [[AnExpensiveCanonCamera alloc] init],
                [[TheCheapestCameraEver alloc] init]
              ];
              for(NSObject<CameraDevice> * camera in cameras){
                if([camera respondsToSelector:@selector(flashStrength)]){
                  NSLog(@"%@ camera has flash strength %i",
                                [camera manufacturerName],
                                [camera flashStrength]);
                } else {
                  NSLog(@"%@ camera has no flash", [camera manufacturerName]);
                }
              }
            ```

            \begin{figure}[htb]\begin{center}\caption{019\_protocols.m part 2}\end{center}\end{figure}
    - "Categories":
        slides:
          - >
            Categories allow you to mix in new code to existing classes without having to change the original source code for those classes.  Examples of categories include automatically adding special serialization rules to NSObject.
          - >
            You "can't" add instance variables to a class with categories; they are purely for adding new methods to a class, but cannot change the memory layout of a class after the fact.
          - >
            # Category declaration

            ```objectivec
              @interface NSDictionary(AsJson)

              -(NSString *) asJson;

              @end

              @implementation NSDictionary(AsJson)

              -(NSString *) asJson {
                  NSData * jsonData = [NSJSONSerialization dataWithJSONObject:self
                                                                      options:0
                                                                        error:nil];
                  return [[NSString alloc] initWithData:jsonData
                                               encoding:NSUTF8StringEncoding];
              }

              @end
            ```

            \begin{figure}[htb]\begin{center}\caption{020\_categories.m part 1}\end{center}\end{figure}
          - >
            # Category usage

            ```objectivec
              #import "NSDictionary+AsJson.h"

              void main(){
                NSLog(@"Dictionary as json: %@",
                            [@{ @"A string": @"String!",
                                @"A number": @(20),
                                @"An Array": @[@(1), @(2), @(3)]} asJson]);
              }
            ```

            \begin{figure}[htb]\begin{center}\caption{020\_categories.m part 2}\end{center}\end{figure}
    - "Memory management":
        slides:
          - >
            <% figure("Memory Management circa 1973") do %>
              <%= graphic("1973.jpg", 0.5) %>
            <% end %>
          - >
            C based languages have traditionally used `malloc` and `free` as the means by which memory was allocated on demand. This code looked something like:

            ```c
              #include <stdio.h>
              #include <stdlib.h>

              int main(){
                int * anInteger = malloc(sizeof(int));
                *anInteger = 10;
                printf("Integer value is %i", *anInteger);
                free(anInteger);
                return 0;
              }
            ```
          - >
            `malloc` and `free` allocated memory on the heap; it was the programmer's responsibility to indicate when a particular item was ready to be released back to the operating system.
          - >
            <% figure("Memory Management circa 1983") do %>
              <%= graphic("1983.jpg", 0.5) %>
            <% end %>
          - >
            Objective C used an "easier" means of managing the memory for its objects: reference counting.

            Reference counting allowed Objective C programmers to write code that looked like this:

            ```objectivec
              NSString * c = [[NSString alloc] initWithString:@"This is a string"];
              NSLog(@"String is %@", c);
              [someOtherObject setString:c];
              [c release];
            ```
          - >
            Each object would respond to two methods: `retain` and `release`. Retain would increment an object's retain count, and release would decrement. When an object's retain count reached 0, it was considered "deallocated", and its memory on the heap would be available for use by other objects.
          - >
            Objects could also be flagged as `autorelease`, which would send a release to an object at some point in the future. Typically this meant after one main NSRunLoop cycle (one UI loop).
          - >
            <% figure("Memory Management circa 2006 - Apple adds Garbage Collection to Objective C") do %>
              <%= graphic("2006.jpg", 0.5) %>
            <% end %>
          - >
            <% figure("Memory Management circa 2008 - The iOS SDK 2.0 and App Store launch. The iPhone does not support Garbage Collection due to performance concerns.") do %>
              <%= graphic("2008.jpg", 0.5) %>
            <% end %>
          - >
            <% figure("Memory Management circa 2011 - ARC") do %>
              <%= graphic("2011.jpg", 0.5) %>
            <% end %>
          - >
            Apple introduces a new tool called [ARC](http://en.wikipedia.org/wiki/Automatic_Reference_Counting) (_Automatic Reference Counting_). Improvements in static code analysis allow Apple to detect and automatically insert retain/release calls for most code.

            In other words, _most of the basic memory management is now done for you_.
          - >
            What ARC _will do_ for you:

            * Let you avoid calling `retain` or `release` on Objective C objects


            What ARC __will not do__ for you:

            * Prevent cyclic memory ownership

            * Allow you to ignore `malloc` or `free` when using C-based apis

            * Allow you to totally ignore memory management

          - >
            # Working With Arc

            ```objectivec
              NSString * s = [[NSString alloc] initWithString:@"Some string"];
              NSLog(@"My string is %@", s);
              // That's it.
            ```
          - >
            # Working With Arc

            ```objectivec
              NSString * s = [[NSString alloc] initWithString:@"Some string"];
              [someOtherObject setString:s];

              // and in the someOtherObject's implementation

              @interface SomeOtherObject

              @property(strong,nonatomic) NSString * string;

              @end
            ```
          - >
            # Working With Arc

            Usage of ARC is by default on all new iOS projects. You can choose to disable it and manually manage memory. You can also still manually manage memory created through `malloc` and `free` if necessary.
    - "More learning":
        slides:
          - >
            Objective C is a deep language.  There are lots of resources on the web and your computer where you can learn more. The best is easily the XCode documentation, but there are blogs out there that can provide invaluable help:

            * Mike Ash's [NSBlog](http://www.mikeash.com/pyblog/)

            * [objc.io](http://www.objc.io/)

            * [NSHipster](http://nshipster.com/)

            * [Apple Developer Forums](http://developer.apple.com/devforums/)

  - "iPhone App Basics: UIViewControllers":
    - "MVC, as applied to an app":
        slides:
          - >
            Apple strongly encourages you to adhere to Model View Controller pattern
            <% figure("Model, View and Controller") do %>
              <%= graphic("mvc.jpg", 0.5) %>
            <% end %>
    - "Application \\Rightarrow Window \\Rightarrow View Controller(s) \\Rightarrow View(s) + Models":
        slides:
          - >
            On iOS, a UIApplication ( your app ) typically has one UIWindow, which is the primary UIView upon which everything else displays.  A UIView is "just" a rectangle upon which you draw things.
          - >
            Almost everything visual is a UIView (except the things that aren't).
          - >
            <% figure("UIViews are everything") do %>
              <%= graphic("UIViewExample.pdf", 0.35) %>
            <% end %>
          - >
            <% figure("UIViews are almost everything") do %>
              <%= graphic("UIViewExample2.pdf", 0.35) %>
            <% end %>
          - >
            UIViewControllers are objects that manage what the views on screen are currently doing; typically where you write event handling code, user interaction code, and interact with your models.
          - >
            There is no "official" model object in this pattern. Your business objects are the models, however you decide to implement them.
    - "Storyboards":
        slides:
          - >
            Storyboards let you visualize the interaction between UIViewControllers. You can design both the UIView layout and the interaction between UIViewControllers using the Storyboard designer.
              <% figure("The Storyboard designer") do %>
                <%= graphic("storyboard.jpg", 0.5) %>
              <% end %>
          - >
            Storyboards are comprised of __scenes__ and __segues__. A __scene__ represents a UIViewController's presentation. A __segue__ is the transition between __scenes__, and carry information about the transition origin and destination, as well as the nature of the transition.
    - "Lab 2":
        slides:
          - >
            Create a new "Single View" project
            <% figure("Create a new project") do %>
              <%= graphic("NewProject.png", 0.5) %>
            <% end %>
          - >
            Add a new NSObject subclass of "UIVIewController" to the project named "DetailViewController"
            <% figure("New Objective C class") do %>
              <%= graphic("NewObjectiveCClass.png", 0.5) %>
            <% end %>
            <% figure("Subclassing UIViewController") do %>
              <%= graphic("DetailViewController.png", 0.5) %>
            <% end %>
          - >
            Add a "UIViewController" object from the Object library on to your storyboard.
            <% figure("The UIViewController object in the Library") do %>
              <%= graphic("SelectViewControllerFromLibrary.png", 0.25) %>
            <% end %>
            <% figure("Drop UIViewController on Storyboard") do %>
              <%= graphic("DropViewControllerOnToStoryboard.png", 0.5) %>
            <% end %>
          - >
            Set the subclass of the UIViewController to "DetailViewController".
            <% figure("Setting the UIViewController subclass") do %>
              <%= graphic("ChooseViewControllerSubclass.png", 0.5) %>
            <% end %>
          - >
            Double click on the first UIViewController in the stoyrboard and add a button with the text "Show Detail" to its scene.
            <% figure("Drag a button to the scene") do %>
              <%= graphic("DragButtonToStoryboard.png", 0.5) %>
            <% end %>
          - >
            Select the button, and view its outlets in the inspector pane. Drag from the `action` outlet under `Triggered Segues` to the "Detail View Controller" scene in your storyboard. Choose "Modal" when asked what sort of segue style will be used.
            <% figure("Connect the action to the Detail View Controller") do %>
              <%= graphic("ConnectionActionToDetailController.png", 0.5) %>
            <% end %>
          - >
            Double click on the Detail View Controller and add a button to its scene with the text "Close".
          - >
            Add the following code to `DetailViewController.h`

            ```objectivec
              -(IBAction) dismissDetailView:(id) sender;
            ```
          - >
            Add the following code to `DetailViewController.m`

            ```objectivec
              -(IBAction) dismissDetailView:(id) sender {
                [self dismissViewControllerAnimated:YES completion:nil];
              }
            ```
          - >
            In your Storyboard, select the "Close" button you added to the Detail View Controller, and connect its "Touch Up Inside" outlet to the Detail View Controller. Select the "dismissDetailView:" selector when prompted which selector to connect to.

            <% figure("Connect the action to the dismiss selector") do %>
              <%= graphic("ConnectToDismissSelector.png", 0.5) %>
            <% end %>
          - >
            Run the project!

            <% figure("Yay, it works!") do %>
              <%= graphic("yay.jpg", 0.5) %>
            <% end %>
          - >
            _One more thing_: Add another button on the Detail View controller that opens another View Controller as a modal, and this new view controller has a button on it that when tapped opens an alert box that says "Hello World".
    - "UINavigationController":
        slides:
          - >
            UINavigationController is a stack based manager of view controllers that the user can navigate through. The tiny left-facing back arrow present in most iOS apps is its most obvious characteristic.

            <% figure("UINavigationController at work") do %>
              <%= graphic("UINavigationControllerInAction.png", 0.5) %>
            <% end %>
          - >
            <% figure("Items managed by UINavigationController ") do %>
              <%= graphic("UIViewExample3.pdf", 0.35) %>
            <% end %>
          - >
            Every UIViewController managed by a UINavigationController has a reference to that UINavigationController in `[self navigationController]`.

            ```objectivec
              -(void) viewDidLoad {
                [super viewDidLoad];
                NSLog(@"There are currently %i controllers in the navigation stack",
                        self.navigationController.childViewControllers.count);
              }
            ```
          - >
            You can add another UIViewController to the navigation stack by using the `push` segue when connecting view controllers in Storyboard.

            <% figure("Selecting the push segue") do %>
              <%= graphic("SelectPushSegue.png", 0.5) %>
            <% end %>

            _Note:_ This segue will only work if you've already set up a UINavigationController, it will not automatically create a UINavigationController for you.
          - >
            You can also push UIViewControllers on the stack manually.

            ```objectivec
              MyViewController * controller = [[MyViewController alloc] initWithNibName:nil
                                                                        bundle:nil];
              [[self navigationController] pushViewController:controller animated:YES];
            ```
    - "Lab 3":
        slides:
          - >
            Create a new "Single View" project
            <% figure("Create a new project") do %>
              <%= graphic("NewProject.png", 0.5) %>
            <% end %>
          - >
            Open the project's storyboard and add a new "UINavigationController" to the storyboard.
            <% figure("Select UINavigationController in the Object library") do %>
              <%= graphic("UINavigationControllerInLibrary.png", 0.5) %>
            <% end %>
          - >
            Drag the storyboard's "initial scene" arrow from the default view controller scene to the UINavigationController you placed.
            <% figure("Drag the initial scene arrow to the UINavigationController") do %>
              <%= graphic("DragInitialSceneArrow.png", 0.25) %>
            <% end %>
          - >
            Drag the "root view controller" outlet from the UINavigationController to the default view controller in the storyboard.
            <% figure("Change the root view controller outlet") do %>
              <%= graphic("ChangeRootViewController.png", 0.25) %>
            <% end %>
          - >
            Add a new NSObject subclass of "UIVIewController" to the project named "DetailViewController"
            <% figure("New Objective C class") do %>
              <%= graphic("NewObjectiveCClass.png", 0.5) %>
            <% end %>
            <% figure("Subclassing UIViewController") do %>
              <%= graphic("DetailViewController.png", 0.5) %>
            <% end %>
          - >
            Add a "UIViewController" object from the Object library on to your storyboard.
            <% figure("The UIViewController object in the Library") do %>
              <%= graphic("SelectViewControllerFromLibrary.png", 0.25) %>
            <% end %>
            <% figure("Drop UIViewController on Storyboard") do %>
              <%= graphic("DropViewControllerOnToStoryboard.png", 0.5) %>
            <% end %>
          - >
            Set the subclass of the UIViewController to "DetailViewController".
            <% figure("Setting the UIViewController subclass") do %>
              <%= graphic("ChooseViewControllerSubclass.png", 0.5) %>
            <% end %>
          - >
            Double click on the first UIViewController in the stoyrboard and add a button with the text "Show Detail" to its scene.
            <% figure("Drag a button to the scene") do %>
              <%= graphic("DragButtonToStoryboard.png", 0.5) %>
            <% end %>
          - >
            Select the button, and view its outlets in the inspector pane. Drag from the `action` outlet under `Triggered Segues` to the "Detail View Controller" scene in your storyboard. Choose "Push" when asked what sort of segue style will be used.
            <% figure("Connect the action to the Detail View Controller") do %>
              <%= graphic("ConnectionActionToDetailController.png", 0.5) %>
            <% end %>
          - >
            Double click on the Detail View Controller and add a label to its scene with the text "Valuable Detail".
            <% figure("Select and place the Label control") do %>
              <%= graphic("SelectLabelControl.png", 0.5) %>
            <% end %>
          - >
            Select the navigation bar in the detail view controller, and change its title attribute to "My Detail View".
            <% figure("Select UINavigationItem in controller") do %>
              <%= graphic("SelectUINavigationItem.png", 0.5) %>
            <% end %>
            <% figure("Change UINavigationItem title") do %>
              <%= graphic("ChangeUINavigationItemTitle.png", 0.5) %>
            <% end %>
          - >
            Run the app!
            <% figure("Put it on the App Store!") do %>
              <%= graphic("distinguishedyay.jpg", 0.5) %>
            <% end %>
          - >
            _One more thing_: Add a button on your Detail View Controller that opens up a new View Controller that shows an image.
    - "UITabBarController":
        slides:
          - >
            A UITabBar is the control that sits at the bottom of a screen, and allows you to switch between different views based on the button you click.

            <% figure("UITabBar examples") do %>
              <%= graphic("tabbar.png", 0.25) %>
            <% end %>
          - >
            A UITabBarController swaps in UIViewControllers assigned to it when users click on the associated button
          - >
            Each UIViewController has a tabBarItem property that UITabBarController uses to populate its UITabBar
          - >
            <% figure("UITabBarController example") do %>
              <%= graphic("UIViewExample4.pdf", 0.30) %>
            <% end %>
          - >
            <% figure("Sir Not Appearing In This Class") do %>
              <%= graphic("sir.jpg", 0.35) %>
            <% end %>
    - "UITableViewController":
          - >
            UITableViews make up the majority of navigational aids in most iOS apps. If you see a vertical list of selectable items, it is almost certainly a UITableView.

            <% figure("UITableView examples") do %>
              <%= graphic("tableview.png", 0.35) %>
            <% end %>
          - >
            A UITableView presents data in two dimensions: __sections__ and __rows__. For any section __N__, there may be __M__ rows of information to present.
          - >
            Each cell in a UITableView is represented by a UITableViewCell. A UITableViewCell in its default implementation allows for a title label, a left aligned image view, and an optional accessory view that is right aligned.

            <% figure("UITableViewCell default style") do %>
              <%= graphic("UITableViewCell.png", 0.35) %>
            <% end %>
          - >
            A UITableView has special code that allows it to only create as many UITableViewCells as are currently on the screen, as opposed to the number of rows in your source data.  This allows you to easily support paging through many thousands of items w/ negligible performance impact.
          - >
            A UITableViewController has many pre-filled methods to make interacting with UITableViews easier. It is a subclass of UIViewController, and is merely a convenience to the programmer.

            <% figure("UITableView example") do %>
              <%= graphic("UIViewExample5.pdf", 0.30) %>
            <% end %>
    - "Lab 4":
        slides:
          - >
            Create a new "Single View" project
            <% figure("Create a new project") do %>
              <%= graphic("NewProject.png", 0.5) %>
            <% end %>
          - >
            Open the project's storyboard and add a new "UINavigationController" to the storyboard.
            <% figure("Select UINavigationController in the Object library") do %>
              <%= graphic("UINavigationControllerInLibrary.png", 0.5) %>
            <% end %>
          - >
            Drag the storyboard's "initial scene" arrow from the default view controller scene to the UINavigationController you placed.
            <% figure("Drag the initial scene arrow to the UINavigationController") do %>
              <%= graphic("DragInitialSceneArrow.png", 0.25) %>
            <% end %>
          - >
            Add a new subclass of NSObject to your project that is a subclass of "UITableViewController".

            <% figure("Add a new subclass of UITableViewController") do %>
              <%= graphic("NewSubclassOfUITableViewController.png", 0.5) %>
            <% end %>
          - >
            Change the subclass of the UITableViewController connected to your UINavigationController in Storyboard to the UITableViewController you created.

            <% figure("Change subclass to new UITableViewController") do %>
              <%= graphic("ChangeSubclassToTableViewController.png", 0.5) %>
            <% end %>
          - >
            Add the following code to PCTableViewController.h:

            ```objectivec
              @property NSArray * items;
            ```

            Add the following code to PCTableViewController.m:

            ```objectivec
              -(void) viewDidLoad {
                [super viewDidLoad];
                self.items = @[@"One", @"Two", @"Three"];
              }
            ```
          - >
            Change the method `numberOfSectionsInTableView:(UITableView *) tableView` in PCTableViewController.m to return 1.
          - >
            Change the method `tableView:(UITableView *) tableView cellForRowAtIndexPath:(NSIndexPath *) path` to return `self.items.count`.
          - >
            Change the method `tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath` to:

            ```objectivec
              UITableViewCell *cell = [tableView
                 dequeueReusableCellWithIdentifier:@"DefaultCell"
                                      forIndexPath:indexPath];

              cell.textLabel.text = [self.items objectAtIndex:indexPath.row];

              return cell;
            ```
          - >
            Double click on the table view controller in Storyboard and select the prototype UITableViewCell. Change its reuse identifier to "DefaultCell".

            <% figure("Change Reuse Identifier") do %>
              <%= graphic("ChangeReuseIdentifier.png", 0.5) %>
            <% end %>
          - >
            In the `PCViewController.h`, add the following code.

            ```objectivec
              @property NSString * name;
              @property IBOutlet UILabel * nameLabel;
            ```
          - >
            In Storyboard, drag a UILabel to PCViewController and connect it to the nameLabel outlet.

            <% figure("Connect the UILabel to the nameLabel outlet") do %>
              <%= graphic("ConnectLabelToOutlet.png", 0.5) %>
            <% end %>
          - >
            In PCViewController.m, add the following code:

            ```objectivec
              -(void) viewDidLoad {
                [super viewDidLoad];
                self.nameLabel.text = [NSString stringWithFormat:@"Name: %@", self.name];
              }
            ```
          - >
            In Storyboard, select the prototype cell in the table view controller and connect its "selection" triggered segue to the PCViewController and choose "Push".

            <% figure("Connect the selection segue of the UITableViewCell") do %>
              <%= graphic("ConnectSelectionSegue.png", 0.5) %>
            <% end %>
          - >
            In PCTableViewController.m, uncomment the method `prepareForSegue:sender:` and add the following code:

            ```objectivec
              PCViewController * c = (PCViewController *)[segue destinationViewController];
              c.name = [self.items objectAtIndex:self.tableView.indexPathForSelectedRow.row];
            ```

            Add the following line to the top of the file:

            ```objectivec
              #import "PCViewController.h"
            ```
          - >
            Run it!
            <% figure("Time to get pumped") do %>
              <%= graphic("hulk.jpg", 0.5) %>
            <% end %>
          - >
            _One more thing_: Add a JSON file to your project that is an array of items. Deserialize it in your UITableViewController, and use the information from the JSON file to populate your UITableView and UIViewController.
    - "An Aside: The Delegate Pattern":
        - >
          You may have noticed that UITableViewController had odd methods like `- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section`. Why does the UITableViewController need to have a UITableView passed to its numberOfRowsInsection method?
        - >
          The delegate pattern allows for a weak binding between two objects, such that a "delegate" can be queried for configuration information and special behavior from an acting object.
        - >
          Objective C formal protocols are typically how a delegate can indicate at compile time that it provides certain functionality. See UITableViewDelegate and UITableViewDataSource.
        - >
          The delegate pattern is used widely throughout Apple frameworks.

          <% figure("Delegate usage throughout the documentation") do %>
            <%= graphic("DelegateGrep.png", 0.5) %>
          <% end %>
    - "Review Concepts: UIViewController Basics":
        - >
          Build an iOS app that:

          * Has a UINavigationController

          * Loads a UITableViewController as its first scene

          * Populates the UITableViewController rows names taken from a JSON file in the local file system

          * Populates the UITableViewController rows with images specified from the JSON file

          * When a table row is selected, loads a detail view controller that presents the name and image that the user selected

    - "NSURL, NSURLRequest,  NSMutableURLRequest AND NSURLConnection":
        - >
          NSURL is meant to only represent a single resource location

          ```objectivec
            NSURL * theUrl = [NSURL URLWithString:@"http://bootstrapping-ios.com/"];
          ```
        - >
          NSURL can be allocated to represent either a filesystem location, or a web resource

          ```objectivec
            NSURL * aWebUrl = [NSURL URLWithString:@"http://news.ycombinator.org/"];
            NSURL * aFileUrl = [NSURL fileURLWithPath:[[NSBundle mainBundle] pathForResource:@"index" ofType:@"json"]]];
          ```
        - >
          NSURLRequest and NSMutableURLRequest represent specific web resources that you'd like to initiate a connection to; NSURLRequest should be used for simple GET HTTP requests,while NSMutableURLRequests can be used for more complex HTTP requests (POST, PUT, file uploads).
        - >
          NSMutableURLRequest allows you to set HTTP headers, the HTTP method used, and the request body.
        - >
          ```objectivec
            NSURLRequest * request = [NSURLRequest
              requestWithURL:[NSURL URLWithString:@"http://bootstrapping-ios.com/"]];

            NSMutableURLRequest *  customRequest = [NSMutableURLRequest
              requestWithURL:[NSURL URLWithString:@"http://bootstrapping-ios.com/"]];
            [customRequest setHTTPMethod:@"POST"];
            [customRequest setValue:@"Some-Token"
                 forHTTPHeaderField:@"X-Request-Token"];
            [customRequest setValue:@"application/x-www-form-encoded"
                 forHTTPHeaderField:@"Content-Type"];
            [customRequest setHTTPBody:[@"some-form=values"
                     dataUsingEncoding:NSUTF8StringEncoding]];
          ```
        - >
          NSURLConnection can send data both synchronously or asynchronously. Asynchronous response information is passed back to the connection delegate via the NSURLConnectionDelegate, NSURLConnectionDataDelegate and NSURLConnectionDownloadDelegate protocols.
        - >
          NSURLConnection initiates the download and returns the NSHTTPURLResponse which contains the body of the response, as well as http status code and response headers.

          ```objectivec
            NSURLRequest * request = [NSURLRequest
              requestWithURL:[NSURL URLWithString:@"http://bootstrapping-ios.com/"]];

            NSError * error;
            NSHTTPURLResponse * response;
            NSData * syncResponse = [NSURLConnection sendSynchronousRequest:request
              returningResponse:&response
              error:&error];

            NSURLConnection * asyncConnection = [[NSURLConnection alloc]
              initWithRequest:request
              delegate:self
              startImmediately:YES];
          ```
        - >
          NSURLSession adds conveniences for downloading content in the background.
    - "Lab 5":
        - >
          Create a new "Single View" project
          <% figure("Create a new project") do %>
            <%= graphic("NewProject.png", 0.5) %>
          <% end %>
        - >
          Open the project's storyboard and add a new "UINavigationController" to the storyboard.
          <% figure("Select UINavigationController in the Object library") do %>
            <%= graphic("UINavigationControllerInLibrary.png", 0.5) %>
          <% end %>
        - >
          Drag the storyboard's "initial scene" arrow from the default view controller scene to the UINavigationController you placed.
          <% figure("Drag the initial scene arrow to the UINavigationController") do %>
            <%= graphic("DragInitialSceneArrow.png", 0.25) %>
          <% end %>
        - >
          Add a new subclass of NSObject to your project that is a subclass of "UITableViewController".

          <% figure("Add a new subclass of UITableViewController") do %>
            <%= graphic("NewSubclassOfUITableViewController.png", 0.5) %>
          <% end %>
        - >
          Change the subclass of the UITableViewController connected to your UINavigationController in Storyboard to the UITableViewController you created.

          <% figure("Change subclass to new UITableViewController") do %>
            <%= graphic("ChangeSubclassToTableViewController.png", 0.5) %>
          <% end %>
        - >
          In the `viewDidLoad` method of your `UITableViewController`, initialize a request to the URL:

          ```
            http://bootstrapping-ios.com/echo?names=one&\
                                                names=two&\
                                                names=three
          ```

          Using NSURLConnection, asynchronously request the above JSON, deserialize it into an NSArray, and then reload your tableview.
        - >
          You will need to have your view controller adopt specific methods from the NSURLConnectionDelegate and  NSURLConnectionDataDelegate protocols. You will also need to store the request data in something like NSMutableData.
        - >
          Run the app!
          <% figure("Basically an expert") do %>
            <%= graphic("distinguishedyay.jpg", 0.5) %>
          <% end %>
        - >
          _One more thing_: Change your request to a POST request (`NSMutableURLRequest` and `setHTTPMethod:`) with `application/x-www-form-urlencoded` content type (`setValue:forHTTPHeaderField:`), and instead of sending a querystring in the URL, send the key value pairs in the HTTP body (`setHTTPBody:`).
        - >
          _And another thing_: Select your TableViewController and enable "Refreshing" in its attributes. A UIRefreshControl will be added to your TableViewController.

          <% figure("Select the refresh control") do %>
            <%= graphic("RefreshControlSelected.png", 0.5) %>
          <% end %>
        - >
          Connect the UIRefreshControl's Value Changed outlet to an IBAction method on your TableViewController that triggers a new download. Tell the refresh control to change its appearance through `[self.refreshControl beginRefreshing]` and `[self.refreshControl endRefreshing]`.
    - "NSTimer, NSRunLoop, NSThread and the Event Loop":
        - >
          Cocoa represents application threads using the `NSThread` object. Each `NSThread` has an `NSRunLoop` associated with it, which is responsible for managing IO and timer events.
        - >
          The main application thread (the UI thread) is one of a set of default threads created for you.  Any operations that occur on this main thread can cause the user interface to become non-responsive; it is important that you defer long running processes to outside this thread.
        - >
          To perform an action at some later point, or on an interval, you can register an NSTimer with the current NSRunLoop. An NSTimer will invoke a selector you specify on a schedule you control.

          ```objectivec
            [NSTimer scheduledTimerWithTimeInterval:10.0
                target:self
                selector:@selector(runEveryTenSeconds:)
                userInfo:nil
                repeats:YES];

            -(void) runEveryTenSeconds:(NSTimer *) {
              NSLog(@"Timer fired");
            }
          ```
        - >
          These timer actions occur in the thread they were scheduled from, so be cautious about scheduling expensive operations.
    - "Lab 6":
        - >
          Create a new "Single View" project
          <% figure("Create a new project") do %>
            <%= graphic("NewProject.png", 0.5) %>
          <% end %>
        - >
          Open the project's storyboard and add a new "UINavigationController" to the storyboard.
          <% figure("Select UINavigationController in the Object library") do %>
            <%= graphic("UINavigationControllerInLibrary.png", 0.5) %>
          <% end %>
        - >
          Drag the storyboard's "initial scene" arrow from the default view controller scene to the UINavigationController you placed.
          <% figure("Drag the initial scene arrow to the UINavigationController") do %>
            <%= graphic("DragInitialSceneArrow.png", 0.25) %>
          <% end %>
        - >
          Add a new subclass of NSObject to your project that is a subclass of "UITableViewController".

          <% figure("Add a new subclass of UITableViewController") do %>
            <%= graphic("NewSubclassOfUITableViewController.png", 0.5) %>
          <% end %>
        - >
          Change the subclass of the UITableViewController connected to your UINavigationController in Storyboard to the UITableViewController you created.

          <% figure("Change subclass to new UITableViewController") do %>
            <%= graphic("ChangeSubclassToTableViewController.png", 0.5) %>
          <% end %>
        - >
          In the `viewDidLoad` method of your `UITableViewController`, initialize a request to the URL:

          ```objectivec
            NSTimeInterval since1970 = [[NSDate date] timeIntervalSince1970];
            NSURL * theUrl = [NSURL URLWithString:
            [NSString
              stringWithFormat:@"http://bootstrapping-ios.com/\echo?names=one-%f\
                  &names=two-%f\
                  &names=three-%f",
            since1970, since1970, since1970]];
          ```

          Using NSURLConnection, asynchronously request the above JSON, deserialize it into an NSArray, and then reload your tableview.
        - >
          Create an NSTimer and schedule refreshes of the data every 10 seconds.

          ```objectivec
            timer = [NSTimer scheduledTimerWithTimeInterval:5.0
              target:self
              selector:@selector(doRefresh:)
              userInfo:nil
              repeats:YES];
          ```

          Add a method called dealloc that cancels the timer:

          ```objectivec
            -(void) dealloc {
              [timer invalidate];
              timer = nil;
            }
          ```
        - >
          Run the app!
          <% figure("Yay!") do %>
            <%= graphic("distinguishedyay.jpg", 0.5) %>
          <% end %>
        - >
          _One more thing_: Add a call to sleep() (`man 3 sleep`) in your timer that intentionally delays response time of the refresh. Observe how UI suffers as the timer action takes longer to execute.
    - "Installing on the iOS Device":
        - >
          So far we've been running everything on the simulator. In order to run code on our device, we need to do two things:


          * Have a valid code signing certificate

          * Have a valid provisioning profile

        - >
          A code signing certificate allows us to prove we are the trusted origin of our code. A provisioning profile creates the association between the certificate and the devices that it's allowed to run on.
        - >
          You will need a separate certificate and profile for:

          * Development deployment

          * AdHoc deployment

          * AppStore deployment

          * Enterprise deployment
        - >
          XCode will generally create the files you need, but you may manually create (and debug) the requisite files through:

          * The XCode Organizer \menu{Window > Organizer}


          <% figure("XCode Organizer") do %>
            <%= graphic("Organizer.png", 0.5) %>
          <% end %>


        - >
          * iTunes DevCenter [https://developer.apple.com/account/overview.action](https://developer.apple.com/account/overview.action)


          <% figure("DevCenter") do %>
            <%= graphic("DevCenter.png", 0.5) %>
          <% end %>


    - "Lab 7":
        - >
          Open up "Lab 6" in XCode.
        - >
          Connect your iPhone to your machine.
        - >
          Select the iOS device in the "Destination" dropdown.

          <% figure("Select your iOS device") do %>
            <%= graphic("SelectDevice.png", 0.5) %>
          <% end %>
        - >
          Run the app. If you've never actually ran a developer app on your device before, XCode should automatically create the files you need to sign code for the device.

          Alternatively, you can manually set the device to be a developer device on your account by adding it to the member center in XCode Organizer.
        - >
          <% figure("Adding to the Member Center manually") do %>
            <%= graphic("AddToMemberCenter.png", 0.5) %>
          <% end %>
        - >
          While the app is running on your device, you can:

          * Access Console output in Organizer


          <% figure("Watching console output") do %>
            <%= graphic("DeviceConsole.png", 0.5) %>
          <% end %>
        - >
          * Set breakpoints and inspect memory in XCode


          <% figure("Inspecting breakpoints") do %>
            <%= graphic("InspectAtBreakpoints.png", 0.5) %>
          <% end %>
        - >
          * Interactively query memory at breakpoints with LLDB


          <% figure("Querying objects and running code via LLDB") do %>
            <%= graphic("LLDB.png", 0.5) %>
          <% end %>
        - >
          * Observe basic system metrics


          <% figure("Watching system metrics") do %>
            <%= graphic("AppSystemMetrics.png", 0.5) %>
          <% end %>
    - "Custom Views":
        - >
          Views are descendants of `UIView`, and have several properties that allow for some basic customization. Some commonly used attributes are:

          * `.frame`, of type `CGRect`

          * `.backgroundColor` of type `UIColor`

          * `.alpha` of type `CGFloat`

          * `.transform` of type `CGAffineTransform`

          * `.hidden` of type `BOOL`

        - >
          UIView can be subclassed and customized, just like any other view. A UIView may contain other UIViews to __compose__ a higher order control. They can also draw directly to the screen if you need to manually draw certain types of graphics using an API called `Core Graphics`.
        - >
          Any UIViewController has a `view` attribute which represents the top level view it is currently displaying. You can programmatically add other views to this using methods like `addSubview:`, or you can modify the `view` in Storyboard as we have been doing.
        - >
          Views may have a `tag` associated with them, an integer identifier that allows specific views to be requested with the `viewWithTag:` method of UIView.

          ```objectivec
            UIView * v = [[UIView alloc] initWithFrame:CGRectMake(0., 0., 20., 20.)];
            v.tag = 100;

            [self.view addSubview:v];

            UIView * theView = [self.view viewWithTag:100];
          ```
        - >
          UIViews may also specify certain constraints with respect to their sibling views. This is called `Auto Layout`, and allows for UIViews to change their appearance w/ respect to other views.

          <% figure("Autolayout Constraints") do %>
            <%= graphic("AutoLayoutConstraints.png", 0.5) %>
          <% end %>
        - >
          Additionally, UIViews can have application wide settings applied to them using `UIApperance` objects, which set defaults for object appearance:

          ```objectivec
            [[UINavigationBar appearance] setBarTintColor:[UIColor blackColor]];
            [[UITableViewCell appearanceWhenContainedIn:[UITableView class], nil]
              setBackgroundColor:[UIColor purpleColor]];
          ```
    - "Lab 8":
        - >
          Create a new "Single View" project
          <% figure("Create a new project") do %>
            <%= graphic("NewProject.png", 0.5) %>
          <% end %>
        - >
          Open the project's storyboard and add a new "UINavigationController" to the storyboard.
          <% figure("Select UINavigationController in the Object library") do %>
            <%= graphic("UINavigationControllerInLibrary.png", 0.5) %>
          <% end %>
        - >
          Drag the storyboard's "initial scene" arrow from the default view controller scene to the UINavigationController you placed.
          <% figure("Drag the initial scene arrow to the UINavigationController") do %>
            <%= graphic("DragInitialSceneArrow.png", 0.25) %>
          <% end %>
        - >
          Add a new subclass of NSObject to your project that is a subclass of "UITableViewController".

          <% figure("Add a new subclass of UITableViewController") do %>
            <%= graphic("NewSubclassOfUITableViewController.png", 0.5) %>
          <% end %>
        - >
          Change the subclass of the UITableViewController connected to your UINavigationController in Storyboard to the UITableViewController you created.

          <% figure("Change subclass to new UITableViewController") do %>
            <%= graphic("ChangeSubclassToTableViewController.png", 0.5) %>
          <% end %>
        - >
          Populate your UITableView with data. :)
        - >
          In Storyboard, add the following items to the prototype cell in your UITableView:

          * A UIImageView  (tag 100)


          * A UILabel that is the "Title" label (tag 101)


          * A UILabel that is the "Subtitle" label (tag 102)

        - >
          Add an alignment constraint to the "Title" and "Subtitle" such that they keep a strict right margin with respect to their superview.

          <% figure("Set right margin") do %>
            <%= graphic("SetRightMargin.png", 0.5) %>
          <% end %>
        - >
          In the `tableView:cellForRowAtIndexPath:` method of your table view controller, retrieve the 3 views based on their tag, and set their values respectively.

          ```objectivec
            UIImageView * imageView = [cell viewWithTag:100];
            UILabel * title = [cell viewWithTag:101];
            UILabel * subtitle = [cell viewWithTag:102];
            title.text = @"Title"
            subtitle.text = @"image"
            imageView.image = anImage;
          ```
        - >
          Run the app!
          <% figure("Put it on the App Store!") do %>
            <%= graphic("distinguishedyay.jpg", 0.5) %>
          <% end %>
        - >
          _One more thing_: Using the UIAppearance protocol, set the default font and text color of any UILabel object when your app starts up.
    - "Review Concepts: Integrating With Remote Resources":
        - >
          Build an iOS app that:

          * Uses a UITableViewController to display main content

          * Loads the content for the UITableViewController from a remote JSON file

          * Loads a detail view when a row in the UITableViewController is tapped on

          * Customize the default appearance of UILabels using the UIAppearance class

          * Has a custom UITableViewCell to display the JSON data
    - "Revisiting Some Basics":
        - >
          Instantiating an Objective C object looks like:

          ```objectivec
            NSString * s = [[NSString alloc] init];
          ```

          where `alloc` generates the space for the class, and `init` may be thought of as the constructor.
        - >
          Each class also has the concept of a destructor. The destructor method is named `dealloc`, and is called for you when your object is removed from memory.

          ```objectivec
            -(void) dealloc {
              fclose(myFileHandle);
              [myDatabaseConnection close];
            }
          ```

          Use the dealloc method to teardown resources used only by your object, as well as remove any global references to your object that will no longer be valid when it leaves memory.
        - >
          Each Objective C class can have a number of instance variables, and a number of properties. __Instance variables__ are variables available internally to a given instance of an Objective C object; __properties__ are the public facing API of a given object.

          ```objectivec

            @interface MyClass : NSObject {
              int anInstanceVariable;
              NSString * anotherInstanceVariable;
            }

            @property NSNumber * thisNumberIsAvailableToOtherClasses;

            @end
          ```
        - >
          You can modify instance variable scope if you want the instance variables themselves to be visible outside the instance. The default scope is `@protected`, but you can also use `@public` and `@private`.

          ```objectivec
            @interface MyClass : NSObject {
              @public
              int anInstanceVariable;

              @private
              NSString * anotherInstanceVariable;
              NSNumber * someNumber;

              @protected
              NSDictionary * aDictionary;
            }

            @end
          ```
        - >
          Objective C objects are "just" structs, so if you intend to access a public instance variable, you can do so by using the `->` operator.

          ```objectivec
            MyClass * c = [[MyClass alloc] init];
            NSLog(@"Some int: %i", c->anInstanceVariable);
          ```

          The `->` operator looks up the member variable of the struct pointed to by a pointer.
        - >
          The delegate pattern allows for an object to notify its `delegate` that some event has occurred, or to query its `delegate` for more information. If we were to implement this pattern ourselves, it would look like this:

          ```objectivec

            @protocol SimpleURLDownloader

            -(void) downloadFinishedWithString:(NSString *) content;

            @end

            @interface SimpleURLDownloader : NSObject

            @property(weak) id<SimpleURLDownloaderDelegate> delegate;

            @end
          ```
        - >
          ```objectivec
            @implementation SimpleURLDownloader

            -(void) downloadUrl:(NSURL *) url {
              NSString * urlResponse = MagicallyDownloadData();
              [self.delegate downloadFinishedWithString:urlResponse];
            }

            @end
          ```
        - >
          ```objectivec
            -(void) viewDidLoad {
              SimpleURLDownloader * dl = [[SimpleURLDownloader alloc] init];
              dl.delegate = self;
              [dl downloadUrl:[NSURL URLWithString:@"http://google.com/"]];
            }

            -(void) downloadFinishedWithString:(NSString *) content {
              NSLog(@"Just downloaded google, %@", content);
            }
          ```
    - "iOS App Structure":
        - >
          An iOS app shares common ancestry with Mac OS apps; they are "bundles" (NSBundle) that can contain many resources. So far, we've used the `[NSBundle mainBundle]` accessor to grab a reference to the bundle that contains our app; this reference allows us to query for information included with our app.

          ```objectivec
            [[NSBundle mainBundle] pathForResource:@"file" ofType:@"json"];
            [[NSBundle mainBundle] classNamed:@"MyOwnClass"];
          ```
        - >
          You can inspect the physical layout of an iOS app by opening its contents as seen by the simulator:

          <% figure("App contents") do %>
            <%= graphic("AppContents.png", 0.5) %>
          <% end %>

          These apps live in `~/Library/Application Support/iPhone Simulator/<Simulator Version>`.
        - >
          Along with an `NSBundle` that is associated with our app, there is a `UIApplication`. While the `NSBundle` refers to primarily filesystem items associated with our app, the `UIApplication` is our reference to the currently running instance.

          ```objectivec
            [[UIApplication sharedApplication] setStatusBarHidden:YES
              withAnimation:UIStatusBarAnimationFade];
          ```
        - >
          A UIApplication is created automatically for you when your application is started up. When XCode creates a project for you, it will also automatically create a UIApplication delegate (`UIApplicationDelegate` protocol) that responds to UIApplication events.

          ```objectivec
            - (BOOL)application:(UIApplication *)application
              didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
          ```
        - >
          The methods provided by UIApplicationDelegate are meant to help you handle the transition between application states: active, inactive, background and terminated.


          Your application will usually be rejected if you don't suspend operation correctly in cases where a phone call is received or the app is backgrounded.
        - >
          Your application has access to a number of sandboxed directories. While you don't have write access to anything in the bundle root, you can write to the Documents directory, the Caches directory and the tmp directory.


          Directory paths should be looked up via specific helpers:

          ```objectivec
            NSArray * docDirs = NSSearchPathForDirectoriesInDomains(
                                  NSDocumentsDirectory,
                                  NSUserDomainMask,
                                  YES);
            NSString * actualDir = [docDirs objectAtIndex:0];

            NSString * tmpDir = NSTemporaryDirectory();
          ```
        - >
          Your application may be rejected if you store anything other than user generated content in the Documents directory. Furthermore, the tmp and cache directories have "undefined" clearing schedules, so you cannot guarantee that files placed there will stay there for any length of time.
        - >
          You can use traditional C file access functions (`fopen`, `fread`) to manage file access, or you can use convenience functions provided by the `NSFileManager`, `NSInputStream` and `NSOutputStream` classes.


          Classes like NSData and NSString also have convenience methods like `initWithContentsOfFile:` and `writeToFile:atomically:` to make dealing with the filesystem easier.
    - "Lab 9":
        - >
          Create a new "Single View" project
          <% figure("Create a new project") do %>
            <%= graphic("NewProject.png", 0.5) %>
          <% end %>
        - >
          Open the project's storyboard and add a new "UINavigationController" to the storyboard.
          <% figure("Select UINavigationController in the Object library") do %>
            <%= graphic("UINavigationControllerInLibrary.png", 0.5) %>
          <% end %>
        - >
          Drag the storyboard's "initial scene" arrow from the default view controller scene to the UINavigationController you placed.
          <% figure("Drag the initial scene arrow to the UINavigationController") do %>
            <%= graphic("DragInitialSceneArrow.png", 0.25) %>
          <% end %>
        - >
          Add a new subclass of NSObject to your project that is a subclass of "UITableViewController".

          <% figure("Add a new subclass of UITableViewController") do %>
            <%= graphic("NewSubclassOfUITableViewController.png", 0.5) %>
          <% end %>
        - >
          Change the subclass of the UITableViewController connected to your UINavigationController in Storyboard to the UITableViewController you created.

          <% figure("Change subclass to new UITableViewController") do %>
            <%= graphic("ChangeSubclassToTableViewController.png", 0.5) %>
          <% end %>
        - >
          In the `viewDidLoad` method of your `UITableViewController`, initialize a request to the URL:

          ```
            http://www.bootstrapping-ios.com/echoWait?names=one&\
                                                names=two&\
                                                names=three
          ```

          Using the `writeToFile:atomically:` method of NSData, write the response of the URL to the `NSCachesDirectory` directory. In your `viewDidLoad` method, check for the existence of this file before attempting to perform the network request, and if it exists, load it instead of the network version.
        - >
          <% figure("Put it on the App Store!") do %>
            <%= graphic("distinguishedyay.jpg", 0.5) %>
          <% end %>
        - >
          _One more thing_: Find the cache JSON file in your simulator filesystem.
    - "User Input":
        - >
          iOS user input typically consists of the following two views:

          * `UITextField`: A single line piece of editable text

          * `UITextView`: A multi line text editor


        - >
          These views form the foundation of most user text input, and their simplest use is plain, unadorned text.

          <% figure("Simple UITextField") do %>
            <%= graphic("SimpleUITextField.png") %>
          <% end %>

          However, they can also display attributed strings (`NSAttributedString`), strings which specify special formatting information like bold text, font, files attached to character ranges and more.
        - >
          UITextViews and UITextFields also support custom keyboards. You can specify a custom keyboard (`inputView`) or keyboard accessory (`inputAccessoryView`) which you can use to add special formatting instructions to your user input.

          <% figure("Custom keyboard accessory") do %>
            <%= graphic("CustomKeyboardAccessory.png", 0.5) %>
          <% end %>
    - "Lab 10":
        - >
          Create a new "Single View" project
          <% figure("Create a new project") do %>
            <%= graphic("NewProject.png", 0.5) %>
          <% end %>
        - >
          Open the project's storyboard and add a new "UINavigationController" to the storyboard.
          <% figure("Select UINavigationController in the Object library") do %>
            <%= graphic("UINavigationControllerInLibrary.png", 0.5) %>
          <% end %>
        - >
          Drag the storyboard's "initial scene" arrow from the default view controller scene to the UINavigationController you placed.
          <% figure("Drag the initial scene arrow to the UINavigationController") do %>
            <%= graphic("DragInitialSceneArrow.png", 0.25) %>
          <% end %>
        - >
          Add a new subclass of NSObject to your project that is a subclass of "UITableViewController".

          <% figure("Add a new subclass of UITableViewController") do %>
            <%= graphic("NewSubclassOfUITableViewController.png", 0.5) %>
          <% end %>
        - >
          Change the subclass of the UITableViewController connected to your UINavigationController in Storyboard to the UITableViewController you created.

          <% figure("Change subclass to new UITableViewController") do %>
            <%= graphic("ChangeSubclassToTableViewController.png", 0.5) %>
          <% end %>
        - >
          Using the `NSFileManager` object, query the NSDocumentsDirectory for the list of files it contains (`contentsOfDirectoryAtPath:error:`). Use this list to populate your tableview.
        - >
          Create a detail view that contains a UITextField for a title, and a UITextView for a body. Connect these via IBOutlets to the view controller for this detail view.

          <% figure("Add UITextField and UITextView to Detail view") do %>
            <%= graphic("DetailInputLayout.png", 0.5) %>
          <% end %>
        - >
          Add an NSString property called `path` to the Detail View Controller.
        - >
          Add a "Bar Button Item" to the right hand side of the navigation bar of your table view controller. Change it's text to "New".

          <% figure("Bar Button Item") do %>
            <%= graphic("BarButtonItem.png", 0.5) %>
          <% end %>

          Connect the `action` triggered segue of this outlet to the detail view controller.
        - >
          Connect the `selection` triggered segue of the table view controller cell to the detail view controller. Select the segue itself and change its identifier to "ExistingItem".

          <% figure("Change Segue Identifier") do %>
            <%= graphic("SegueIdentifier.png", 0.5) %>
          <% end %>
        - >
          In the `prepareForSegue:sender:` method of the Table View Controller, check the segue to see if its identifier is equal to "ExistingItem" (`isEqualToString:`). If the identifier is equal, set the path property of the detail view controller equal to the path of the file that the user has selected.
        - >
          Add a "Bar Button Item" to the right hand side of the detail view controller and change its text to "Save". Connect it to an IBAction on the Detail View Controller called `doSave:`.
        - >
          In the `viewDidLoad` method of the Detail View Controller, check to see if the path property has a value. If it does, set the title text field's text property equal to the filename in the path, and the body text view's text property equal to the contents of that file.
        - >
          In the `doSave:` method of the Detail View Controller, check to see if the title property has a string length > 0. If it does, write the contents of the body view to a path equal to the documents directory + the name in the title view.
        - >
          Add code to the table view controller to reload the table whenever the view goes from a hidden to an appearing state `viewDidAppear:`.
        - >
          <% figure("Put it on the App Store!") do %>
            <%= graphic("distinguishedyay.jpg", 0.5) %>
          <% end %>
        - >
          _One more thing_: Serialize the content as a JSON hash instead of a flat file. Put the title and body in the JSON file, and extract it as such when you open the file. Use string methods like `stringByAppendingPathComponent:`, `stringByAppendingPathExtension:` and `stringByReplacingOccurrencesOfString:withString:` to format your pathnames correctly.
        - >
          _One smaller thing_: When the user saves the content, tell the current navigation controller that you want it to pop the currently visible view controller off its view stack.  `popViewControllerAnimated:`.
        - >
          _One other thing_: Adjust the UITextView to the keyboard appearance

          _Thanks Apple!_: [Apple Tech-Note on Fixing UIScrollViews and Auto-Layout](https://developer.apple.com/library/ios/technotes/tn2154/_index.html#//apple_ref/doc/uid/DTS40013309)
        - >
          We'll adjust the keyboard appearance by adding a auto layout constraint between the UITextView and its superview. Then we'll add an IBOutlet of type NSLayoutConstraint to our detail view controller, connect it with the height constraint we created, and adjust its `constant` value at keyboard appearance time.
    - "Core Data":
        - >
          Core Data is a way to map objects and object relationships into some persistent store. It also provides the ability to fetch data subsets from the store using "Fetch Requests", expressions similar in function to SQL statements.
        - >
          Core Data is not SQL.
        - >
          Core Data can be backed by XML (Mac OS only), binary blobs on the filesystem, or SQLite.
        - >
          Core Data is not SQL.
        - >
          Core Data has four components that make up most of its operations:

          * An object model (`NSManagedObjectModel`) which describes a __schema__.

          <% figure("NSManagedObjectModel as seen in XCode") do %>
            <%= graphic("CoreDataObjectModel.png", 0.5) %>
          <% end %>
        - >
          * A persistent store coordinator (`NSPersistentStoreCoordinator`) which manages operations with the persistent store.

          This object is the one responsible for writing to disk or memory.
        - >
          * A managed object context (`NSManagedObjectContext`), which translates object operations into commands to be issued to the NSPersistentStoreCoordinator.

          This is the object which sees the most use in Core Data, as it will be responsible for handling the `save:` and `delete` calls.
        - >
          * The translation between the persistent store and the logical object (`NSEntityDescription`) which can be used to generate new persistent instances of an object ( `insertNewObjectForEntityForName:inManagedObjectContext:` ) as well as query what properties belong to a given Entity.
        - >
          Core Data supports automatic migration when it's able to infer how to do so correctly. Simple additions and removals are possible; complex migrations may require more complex manual steps using tools like migration identifiers or custom migrations.

          You can request automatic migration from the NSPersistentStore coordinator by initializing it with the options `NSMigratePersistentStoresAutomaticallyOption` and `NSInferMappingModelAutomaticallyOption` set to `@(YES)` in the options dictionary.
        - >
          Core Data also supports the concept of "Fetch Requests", which provide ways to query the persistent store for a set of objects. If you are using the SQLite store, these will be translated into a roughly equivalent SQL, otherwise the entire object graph and index will be inspected.

          You can create precomputed fetch requests in the data model, and retrieve them later by name, or create fetch requests from strings you specify at runtime.
        - >
          ```objectivec
            NSFetchRequest * preMadeRequest = [aManagedObjectModel fetchRequestByName:@"exampleRequest"];
            NSFetchRequest * preMadeRequestWArgs = [aManagedObjectModel fetchRequestByName:@"exampleParamRequest",
              @"search string", @(200)];

            NSFetchRequest * adHocRequest = [[NSFetchRequest alloc] initWithEntityName:@"SomeManagedObjectModel"];
            [adHocRequest setPredicate:
              [NSPredicate predicateWithFormat:@"(age > 21) AND company IN %@", @[@"IBM", @"AMZ"]]];

            NSArray * results = [objectContext executeFetchRequest:adHocRequest error:nil];
        - >
          Predicates (`NSPredicate`) are the language used to describe how a fetch request should be performed. You can test for membership in a set, general equality, range inclusion, string matching and more.

          The `Predicate Programming Guide` in the iOS documentation offers a very detailed review of the full functionality provided by predicates.
        - >
          The typical Core Data setup process looks like:

          ```objectivec
            NSString * docDir = NSSearchPathForDirectoriesInDomains
            (NSDocumentDirectory, NSUserDomainMask, YES)[0];
            NSString * dbPath = [docDir
              stringByAppendingPathComponent:@"example.sqlite"];
            self.objectModel = [NSManagedObjectModel mergedModelFromBundles:nil];
            self.coordinator = [[NSPersistentStoreCoordinator alloc]
              initWithManagedObjectModel:self.objectModel];
            [self.coordinator
              addPersistentStoreWithType:NSSQLiteStoreType
              configuration:nil
              URL:[NSURL fileURLWithPath:dbPath]
              options:nil
              error:nil];
            self.mainContext = [[NSManagedObjectContext alloc] init];
            self.mainContext.persistentStoreCoordinator = self.coordinator;
          ```
        - >
          NSManagedObjectContext is considered __NOT__ thread safe; Apple recommends allocating a separate NSManagedObjectContext per thread if you must access Core Data concurrently.
        - >
          The final result of a Core Data query is a grouping of NSManagedObjects. NSManagedObjects are the logical objects that you create when interacting with Core Data.

          The properties of an NSManagedObject are what are reflected in the persistent store, and are marked as `@dynamic` in their implementation to reflect that their behavior is fulfilled at runtime.
        - >
          ```objectivec
            @interface AModelObject: NSManagedObject
            @property(strong, nonatomic) NSString * name;
            @end

            @implementation AModelObject
            @dynamic name;
          ```
        - >
          NSManagedObjects have their properties represented by NSStrings, NSNumbers, NSDate and NSData. You can also specify special properties that are transformed using a value transformer (default is NSKeyedArchiver and NSKeyedUnarchiver) or have transient values generated at access time.
        - >
          You can also specify object relationships like one-to-one, one-to-many and many-to-many. They can be unidirectional or bidirectional, and Core Data will attempt to maintain object graph consistency.
        - >
          In order to initialize a new instance of a model, you need to tell the `NSEntityDescription` for a given model class to insert it using a given object context:

          ```objectivec
            MyModel * m = [NSEntityDescription
              insertNewObjectForEntityForName:@"MyModel"
              inManagedObjectContext:myObjectContext];
          ```
        - >
          Changes to a model are queued and recorded based on your interaction with their properties. Once you've changed their values, a call to `[myObjectContext save:&error]` will attempt to commit all your changes.

          ```objectivec
            MyModel * m = self.results[0];
            m.name = @"New Name";

            MyModel * o = self.results[1];
            m.name = @"New Name 2";

            [myContext save:nil];
          ```
        - >
          A managed object context can also delete objects using the `deleteObject:` method.
    - "Lab 11":
        - >
          Create a new "Single View" project
          <% figure("Create a new project") do %>
            <%= graphic("NewProject.png", 0.5) %>
          <% end %>
        - >
          Open the project's storyboard and add a new "UINavigationController" to the storyboard.
          <% figure("Select UINavigationController in the Object library") do %>
            <%= graphic("UINavigationControllerInLibrary.png", 0.5) %>
          <% end %>
        - >
          Drag the storyboard's "initial scene" arrow from the default view controller scene to the UINavigationController you placed.
          <% figure("Drag the initial scene arrow to the UINavigationController") do %>
            <%= graphic("DragInitialSceneArrow.png", 0.25) %>
          <% end %>
        - >
          Add a new subclass of NSObject to your project that is a subclass of "UITableViewController".

          <% figure("Add a new subclass of UITableViewController") do %>
            <%= graphic("NewSubclassOfUITableViewController.png", 0.5) %>
          <% end %>
        - >
          Change the subclass of the UITableViewController connected to your UINavigationController in Storyboard to the UITableViewController you created.

          <% figure("Change subclass to new UITableViewController") do %>
            <%= graphic("ChangeSubclassToTableViewController.png", 0.5) %>
          <% end %>
        - >
          Add a new Core Data model to your project.

          <% figure("Create the Core Data model") do %>
            <%= graphic("NewCoreDataDataModel.png", 0.5) %>
          <% end %>
        - >
          Add a new Entity called "Person", and add the following attributes to "Person":

          * Name (String)


          * Birthdate (Date)


          * Vegetarian (Boolean)


          * Salary (Float)
        - >
          Add a new "NSManagedObject" class to your project, and have it map to the "Person" entity you created.

          <% figure("Add the NSManagedObject subclass") do %>
            <%= graphic("NewManagedObjectSubclass.png", 0.5) %>
          <% end %>
        - >
          Create a new detail view controller, and add a UITextField (name), UISlider (salary), UISwitch (vegetarian) and UIDatePicker (birthdate) to its view.

          Connect each of these controls via IBOutlets to the detail view controller.

          <% figure("Example of detail view") do %>
            <%= graphic("ExampleControls.png", 0.5) %>
          <% end %>
        - >
          Add a property to the detail view controller for a Person object.
        - >
          Add a "Save" Bar Button Item to the right hand side of the detail view controller's UINavigationItem.
        - >
          Connect the selected segue from the UITableView of your table view controller to the detail view controller. Label the segue as "ExistingItem".
        - >
          Add a "New" Bar Button Item to the right hand side of the table view controller's UINavigationItem. Connect it's triggered segue outlet to the detail view controller.
        - >
          Initialize your Core Data connection in your application delegate and assign the NSManagedObjectContext to a property.
        - >
          In your table view controller, create a method that will returns an NSArray of all current Core Data objects:

          ```objectivec
            PCAppDelegate * appDelegate = (PCAppDelegate *)[[UIApplication sharedApplication]
                delegate];
            NSFetchRequest * request = [[NSFetchRequest alloc]
                initWithEntityName:@"Person"];
            return [[appDelegate mainContext]
                executeFetchRequest:request error:nil];
          ```

          You will need to access your application delegate in order to get a reference to the NSManagedObjectContext.
        - >
          Change the `prepareForSegue:sender:` method of your tableview such that if the segue it is being called for has the identifier "ExistingItem", the currently selected object is passed to the detail view controller.
        - >
          Change your detail view controller such that each property of the Person object is reflected by the controls in `viewDidLoad`.

          __Note__ that you will want to check if the Person object is nil before doing this. It should be assumed if Person is nil when `viewDidLoad` is called, then you intend to create a new person.
        - >
          Create an `IBAction` called `doSave:` on your detail view controller that has code similar to the following:

          ```objectivec
            -(IBAction) doSave:(id) sender {
              Person * p = self.subject;
              PCAppDelegate * d = (PCAppDelegate *)[[UIApplication sharedApplication]
                delegate];
              NSManagedObjectContext * mainContext = [d mainContext];
              if(!p){
                  p = [NSEntityDescription
                    insertNewObjectForEntityForName:@"Person"
                    inManagedObjectContext:mainContext];
              }
              // sets properties from views
              [mainContext save:nil];
            }
          ```

          Connect the "Save" button on the detail view controller to this method.
        - >
          Change your table view controller such that it reloads its data whenever `viewWillAppear:` is called on it.
        - >
          <% figure("Halfway there :)") do %>
            <%= graphic("distinguishedyay.jpg", 0.5) %>
          <% end %>
        - >
          UISearchBar and UISearchDisplayController work in concert to provide an easy search results display on top of your own controls.
        - >
          UISearchBar handles the user input, while UISearchDisplayController controls its own UITableView to show you specific results.
        - >
          Adding the "Search Bar and Search Display Controller" to your table view controller makes it a table view delegate and datasource of the Search Display Controller as well as the table view it controls.
        - >
          Drag a "Search Bar and Search Display Controller" to your table view controller in Storyboard.

          <% figure("The Search Bar and Search Display Controller") do %>
            <%= graphic("SearchBarAndSearchDisplayController.png", 0.5) %>
          <% end %>
        - >
          Modify your table view controller code and add an NSArray property that will hold your search results, as well as a boolean flag to indicate you are currently searching.

          ```objectivec
            @property NSArray * searchResults;
            @property BOOL isSearching;
          ```

          Also add the `UISearchBarDelegate` and `UISearchDisplayDelegate` protocols to your table view controller.
        - >
          In the `tableView:cellForRowAtIndexPath:` and `tableView:numberOfRowsInSection:`, check if the tableView passed to the method == `self.searchDisplayController.searchResultsTableView`.

          If it does, use the searchResults array to get the value you need, as opposed to the array of all results.
        - >
          * Add the method `searchBar:textDidChange:`, and fill the searchResults array with the results of an NSFetchRequest that used that string as a search term.


          * Add the method `searchDisplayController:didShowSearchResultsTableView:` and `searchDisplayController:didHideSearchResultsTableView:`, and turn the isSearching attribute to true when the results are shown, and false when they are hidden.


          * Change your `prepareForSegue:identifier:` method to get the currently selected row from `self.searchDisplayController.searchResultsTableView` as opposed to `self.tableView` if self.isSearching is true.
        - >
          Mostly there
          <% figure("Put it on the App Store!") do %>
            <%= graphic("distinguishedyay.jpg", 0.5) %>
          <% end %>
        - >
          _One more thing_: Add a button to the detail view to make it delete the record.
    - "Blocks, Grand Central Dispatch, Threading":
        - >
          Apple introduced blocks with Objective C as a way to make certain types of programming easier.

          Blocks are functionally very similar to Ruby blocks or JavaScript function objects.

          ```objectivec
            int multiplier = 7;
            int (^myBlock)(int) = ^(int num) {
                return num * multiplier;
            };
            assert(myBlock(3)==21);
          ```
        - >
          ```objectivec
            int multiplier = 7;
            int (^myBlock)(int) = ^(int num) {
                return num * multiplier;
            };
          ```

          <% figure("Blocks explained") do %>
            <%= graphic("blocks.jpg", 0.5) %>
          <% end %>
        - >
          Blocks may carry references to the stack and heap based on what variables were referred in their body. This can cause unpredictable memory effects; in order to help guide ARC, you can use variable qualifiers like `__weak` and `__strong` to indicate the type of ownership a variable you would like to use in a block should have.

          ```objectivec
            __weak MyClass * weakSelf = self;
            void (^weakRefBlock)() = ^() {
              if(!weakSelf) return;
              return [weakSelf tryMethod];
            };
          ```
        - >
          Blocks may be stored in ivars, passed as method arguments, and generally treated as just another C-type.

          See: [http://fuckingblocksyntax.com/](http://fuckingblocksyntax.com/).
        - >
          Grand Central Dispatch was introduced along with blocks with the primary goal of making concurrency easy.
        - >
          GCD adds the concept of serial and concurrent queues that process blocks on available threads.

          __Serial__ queues process blocks one-by-one in the order that they are received. Only one serial queue is created for you (the main queue), but you can create others with `dispatch_queue_create`.

          __Concurrent__ queues process an undefined number of blocks concurrently. Four concurrent queues with different priority levels are created for you (HIGH, DEFAULT, LOW, BACKGROUND). You cannot create concurrent queues.
        - >
          GCD also has several concurrency structures like semaphores (`dispatch_semaphore_t`), groups (`dispatch_group_t`, for batching) and barriers (`dispatch_barrier_t`, for concurrent synchronization).
        - >
          GCD also provides `select()` like functionality that can trigger blocks whenever an IO object is ready to be read from / written to. (`dispatch_source_create`)
        - >
          A common pattern you'll see in concurrent code is performing a double dispatch, wherein code is executed in a background thread, and then the results submitted to the UI on the main thread:

          ```objectivec
            dispatch_async(dispatch_get_global_queue(
                DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{
                NSString * result = PerformAnExpensiveOperation();
                dispatch_async(dispatch_get_main_queue(), ^{
                  self.resultsLabel.text = result;
                });
            })
          ```
    - "Lab 12":
        - >
          Create a table view controller and hook it up. :)
        - >
          In your `viewDidLoad` method, add code that does the following (replacing the comments with actual code):

          ```objectivec
            dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{
              // synchronously request data from a json url
              // decode it
              dispatch_async(dispatch_get_main_queue(), ^{
                // assign the decoded results to a property
                // reload the table view
              });
            });
          ```
        - >
          Run the app!
          <% figure("Put it on the App Store!") do %>
            <%= graphic("distinguishedyay.jpg", 0.5) %>
          <% end %>


