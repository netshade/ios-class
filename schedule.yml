presentations:
- subtitle: "Day 1"
  title: "Bootstrapping iOS Application Development"
  author: "Chris Zelenak"
  date: "12/02/2013"
  sections:
  - "Intro to class":
      slides:
        - >
          Welcome to the 5-Day Bootstrapping iOS Application Development class. Over the course of these next 5 days, we're going to be reviewing Objective C, UIKit, Core Animation, Core Data, and a host of other technologies you may only know by name.
        - >
          Email me two pictures of you - one serious and one silly - to  chris - at - fastestforward.com
  - "Lab 1":
    - "Create a new iPhone Project":
        slides:
          - >
            Create a new Single View based application in XCode called Lab1 \menu{File > New > Project}

            <% figure("New Projects") do %>
              <%= graphic("NewProject.png", 0.5) %>
            <% end %>
          - >
            Open Main.storyboard in Interface Builder

            <% figure("Main Storyboard") do %>
              <%= graphic("MainStoryboard.png", 0.5) %>
            <% end %>
    - "Add a button":
        slides:
          - >
            Add a button with the text "Hello iPhone"

            <% figure("Drag Button to Storyboard") do %>
              <%= graphic("DragButtonToStoryboard.png", 0.5) %>
            <% end %>
    - "Connect the button to the view controller":
        slides:
          - >
            Add an IBAction selector to the view controller

            ```objectivec
              // In the ViewController.h file
              -(IBAction) helloWorldTapped:(id)sender;
            ```
          - >
            Make it open an alert view

            ```objectivec
              // In the ViewController.m file
              -(IBAction) helloWorldTapped:(id)sender {
                  [[[UIAlertView alloc] initWithTitle:@"Hello World"
                                              message:@"Yay it worked"
                                             delegate:nil
                                    cancelButtonTitle:@"Dismiss"
                                    otherButtonTitles: nil] show];
              }
            ```
          - >
            Connect the `IBAction` to the Button's `Touch Up Inside` action.

            <% figure("Connect Touch Up Inside event to IBAction") do %>
              <%= graphic("ConnectTouchUpToHelloWorld.png", 0.5) %>
            <% end %>
    - "Build and run in simulator":
        slides:
          - >
            Run the simulator with \keys{\cmd + R}, the \menu{Product > Run} menu, or the Play button

            <% figure("Launch Simulator") do %>
              <%= graphic("LaunchInSimulator.png", 0.5) %>
            <% end %>
          - >
            <% figure("It Worked!") do %>
              <%= graphic("YayItWorked.png", 0.5) %>
            <% end %>
  - "Objective C":
    - "Overview":
        slides:
          - >
            Objective C is a superset of C. It tacks on to C a message-passing object model similar to Smalltalk's (see Ruby), with support for reflection and limited runtime dynamic programming.
          - >
            Objective C allows you to use weak and dynamicly typed language features along with the static typing of C; it also allows you to take advantage of runtime method resolution, so that your object's implementation of certain messages may be determined at call-time rather than at compile-time.
          - >
            The language is still physically identical to C in many ways, in that the bulk of your development will be alternating between header files (.h files) and implementation files (.m files). You will also be doing a lot of memory management, which may fill you with either fear or joy, depending on your experience with garbage collected languages.
          - >
            You will also be dealing a lot with many other C-family familiars, such as enumerated integer constants (enums), structs, pass-by-reference v. pass-by-value semantics and pointers.  You don't need to have a very strong grasp on these things immediately, but the more iPhone programming and Objective C programming you do, the more your skills will benefit from a firm grasp of C.
        notes: |
          Objective C is a language similar in many ways to Smalltalk or Ruby. This similarity lies primarily in its object system; objects receive "messages", and may respond to them through statically known methods or runtime selected methods.
          What many people refer to as "Objective C" is actually the various Cocoa family frameworks that Apple has provided, and enhancements to the tooling infrastructure. You could think of Apple's frameworks as the _Standard Library_ of Objective C, much like Ruby or C++'s  standard library.
    - "Review of standard C elements":
        slides:
          - >
            # C Language Elements - Variables

            Variable declaration in C follows the form `TYPE_DESCRIPTION NAME`, eg:

            ```c
              int i = -1; // just an integer
              unsigned int k = 0; // an unsigned integer
              const unsigned int j = 0; // a constant unsigned integer, no reassignment
              const char c = 'c'; // a constant char
              const char * s = "a constant string"; // a pointer to a read-only char array
            ```
          - >
            These are items you'll commonly encouter while doing iPhone programming whose roots belong in the C family:

            ```c
              typedef enum {
                NONE = 0,
                SOME,
                ALL
              } HowMany;

              HowMany i = SOME; // Use of enumerated constant
            ```

            Note the `typedef` in this example, which is creating a type alias to be used later.
          - >
            # C Language Elements - Structs

            ```c
              // Declaring a point in space type
              typedef struct {
                float x;
                float y;
              } APointInSpace;

              APointInSpace point;
              point.x = 20.0;
              point.y = 410.0;

              // C99 style struct instantiation
              APointInSpace point2 = { .x= 21.0, .y=32.0 };
            ```
          - >
            # C Language Elements - Arrays and Pointers

            ```c
              // a constant byte array
              char * constantCharArray = "Or in other words, a string";

              // C99 style array instantiation
              int aListOfNumbers[5] = { 1, 2, 3, 4, 5 };
              int aListOfNumbers[] = { 1, 2, 3, 4, 5};

              // C99 Variable length array declaration
              float aListOfFloats[someQualifier];

              // pointer declaration to NULL
              int * someIntegerPtr = NULL;
              int someInteger = 5;

              // address dereference
              someIntegerPtr = &someInteger;
            ```
          - >
            # C Language Elements - Functions and Function Pointers

            ```c
              float aSimpleAdditionMethod(float a, float b){
                return a + b;
              }

              float aSimpleSubtractionMethod(float a, float b){
                return a - b;
              }

              int aFloatAdditionThatReturnsAnInt(float a, float b){
                return (int) (a + b);
              }

              float (*anFnPtr)(float, float) = aSimpleAdditionMethod;
              anFnPtr(1, 1); // returns 2
              anFnPtr = aSimpleSubtractionMethod;
              anFnPtr(1, 1); // returns 0
            ```
          - >
            # C Language Elements - Preprocessor Statements

            ```c
              #include <stdio.h>
              #define FOO 1
              #define IS_ZERO(n) (n == 0)

              int main(){
                printf("FOO is %i", FOO);
                if(IS_ZERO(0)) {
                  printf("This code is very useful.")
                }
              }
            ```
          - >
            If you never learned C or it's been a long time, a fantastic book for you is ["The C Programming Language"](http://www.amazon.com/C-Programming-Language-2nd-Edition-ebook/dp/B009ZUZ9FW/ref=dp_kinw_strp_1). It doesn't cover many of the newer items in [C99](http://en.wikipedia.org/wiki/C99), but it is a thorough reference to the language fundamentals.

            If you'd like to read more about the new features introduced by C99, read more at [C99Changes](http://home.datacomm.ch/t_wolf/tw/c/c9x_changes.html).
        notes: |
          While it would be disinegenuous to say that C is "easy", its syntax is simple to learn. The underlying concepts and dearth of a 'modern' standard library is where a large part of the perceived difficulty may lie.
          It is important to realize that through the course of your career writing Objective C, a large part of the code and concepts you will be using come from the C world; in reality they are not unique to C at all, but are a closer representation to how a computer models memory and computation.
          An effective way to think about C is as a high level portable assembler; while the output is not portable to different architectures, the source may be cross compiled in a cross platform manner. ( With the understanding that you did not add any platform specificity to your code. :) )
    - "Syntax":
        slides: >
          # Some typical Objective C code

          ```objectivec
            NSString * anExampleString = @"This is a pointer to an NSString object";
            int strLen = [anExampleString length];

            NSString * aSecondString = [anExampleString
              stringByAppendingString:@" that had a second string appended to it"];

            if([anExampleString
                 compare:@"this is a pointer to an nsstring object"
                 options:NSCaseInsensitiveCompare] == NSOrderedSame){
              NSLog(@"The string %@ was case insensitive equal", anExampleString);
            }
          ```
    - "Calling functions":
        slides: >
          Given some Objective C object, like:

          ```objectivec
            NSString * anObject = @"TheObject";
          ```

          you can invoke functionality on that object via the form:

          ```objectivec
           [anObject theMethodName];
          ```

          Method names in Objective C follow the form `initialMethodNameAndArgument:theSecondArgument:theThirdArgument:` .

          \begin{block}{Messages vs. Methods}
          When you see references to "calling a method" or "calling a function" on an object in Objective C, it's best to consider these synonymous with "dispatching a message".

          Objective C objects respond to **messages**, and as you work more with Objective C, it will be more beneficial for you to perceive this as such.
          \end{block}
    - "nil, NULL":
        slides: >
          An object in Objective C may be nil; nil is a "special" object which may have any message at all sent to it, to which it will respond with a nil object.

          ```objectivec
            NSString * anObject = nil;
            if([anObject whoaThisProbablyDoesntExist] == nil){
              NSLog(@"Ah well");
            }
          ```

          nil is the appropriate null object when dealing with pointers to Objective C classes; NULL, on the other hand, is the appropriate null value to use when dealing with pointers to all other types.
        notes: |
          Of course, there is also the unfortunately necessary NSNull object, which pops up in cases where the framework needs to formally recognize a deserialized NULL value (see Property Lists, JSON, etc.). You can test if an object is an NSNull object by comparing it `[NSNull null]`.
    - "Classes":
      slides:
        - >
          # Class interface declaration

          Classes in Objective C are similar to their C++ cousins in that they come in two parts: interface declaration and implementation. The interface declaration portion of a class follows the form:


          ```objectivec
            #import <Foundation/Foundation.h>
            @interface MyNewClass : NSObject {
              int privateVariable1;
              NSString * privateVariable2;
            }

            +(int) someClassMethod;
            -(void) doSomething;
            -(NSString *) giveMeAStringOfLength:(int)length
                              randomizeContents:(BOOL)randomize;
            @end
          ```
        - >
          # Class implementation

          The implementation of this class follows the form:

          ```objectivec
            #import "MyNewClass.h"

            @implementation MyNewClass

            -(id) init {
              self = [super init];
              if(self){
                privateVariable1 = 20;
                privateVariable2 = [[NSString alloc] initWithString:@"Test"];
              }
              return self;
            }

            +(int) someClassMethod {
              return 0;
            }

          ```
        - >
          # Class implementation pt. 2

          ```objectivec
            -(void) doSomething {
              NSLog(@"Something");
            }

            -(NSString *) giveMeAStringOfLength:(int)length
                              randomizeContents:(BOOL)randomize {
              return @"TODO: Make work";
            }

            @end
          ```
    - "Memory management":
        slides:
          - >
            <% figure("Memory Management circa 1973") do %>
              <%= graphic("1973.jpg", 0.5) %>
            <% end %>
          - >
            C based languages have traditionally used `malloc` and `free` as the means by which memory was allocated on demand. This code looked something like:

            ```c
              #include <stdio.h>
              #include <stdlib.h>

              int main(){
                int * anInteger = malloc(sizeof(int));
                *anInteger = 10;
                printf("Integer value is %i", *anInteger);
                free(anInteger);
                return 0;
              }
            ```
          - >
            `malloc` and `free` allocated memory on the heap; it was the programmer's responsibility to indicate when a particular item was ready to be released back to the operating system.
          - >
            <% figure("Memory Management circa 1983") do %>
              <%= graphic("1983.jpg", 0.5) %>
            <% end %>
          - >
            Objective C used an "easier" means of managing the memory for its objects: reference counting.

            Reference counting allowed Objective C programmers to write code that looked like this:

            ```objectivec
              NSString * c = [[NSString alloc] initWithString:@"This is a string allocated on the heap"];
              NSLog(@"String is %@", c);
              [someOtherObject setString:c];
              [c release];
            ```
          - >
            Each object would respond to two methods: `retain` and `release`. Retain would increment an object's retain count, and release would decrement. When an object's retain count reached 0, it was considered "deallocated", and its memory on the heap would be available for use by other objects.
          - >
            Objects could also be flagged as `autorelease`, which would send a release to an object at some point in the future. Typically this meant after one main NSRunLoop cycle (one UI loop).
          - >
            <% figure("Memory Management circa 2006 - Apple adds Garbage Collection to Objective C") do %>
              <%= graphic("2006.jpg", 0.5) %>
            <% end %>
          - >
            <% figure("Memory Management circa 2008 - The iOS SDK 2.0 and App Store launch. The iPhone does not support Garbage Collection due to performance concerns.") do %>
              <%= graphic("2008.jpg", 0.5) %>
            <% end %>
          - >
            <% figure("Memory Management circa 2011 - ARC") do %>
              <%= graphic("2011.jpg", 0.5) %>
            <% end %>
          - >
            Apple introduces a new tool called [ARC](http://en.wikipedia.org/wiki/Automatic_Reference_Counting) (_Automatic Reference Counting_). Improvements in static code analysis allow Apple to detect and automatically insert retain/release calls for most code.

            In other words, _most of the basic memory management is now done for you_.
          - >
            What ARC _will do_ for you:

            * Let you avoid calling `retain` or `release` on Objective C objects


            What ARC __will not do__ for you:

            * Prevent cyclic memory ownership

            * Allow you to ignore `malloc` or `free` when using C-based apis

            * Allow you to ignore memory management

          - >
            # Working With Arc Part 1

            ```objectivec
              NSString * s = [[NSString alloc] initWithString:@"Some string"];
              NSLog(@"My string is %@", s);
              // That's it.
            ```
          - >
            # Working With Arc Part 2

            ```objectivec
              NSString * s = [[NSString alloc] initWithString:@"Some string"];
              [someOtherObject setString:s];

              // and in the someOtherObject's implementation

              @interface SomeOtherObject

              @property(strong,nonatomic) NSString * string;

              @end
            ```
          - >
            You can indicate you don't want to manage the release of an object by
            indicating an object should be autoreleased objects.  Autoreleased objects
            are managed by an object called an NSAutoreleasePool, and are intermittently
            checked to see how many references have been claimed on them.  The pool will
            release the object "at some unknown point in the future"* once all  retains on
            the object have been released.
          - >
            # Memory management in Objective C

            ```objectivec
              // Indicate that the foo object should be managed by
              // the current NSAutoreleasePool
              NSString * foo = [[[NSString alloc]
                                           initWithString:@"Foo"]
                                             autorelease];
              NSLog(@"Foo will be good for now %@", foo);

              [foo retain];
              [foo release];
              NSLog(@"Foo is still good, %@", foo);
              // You may retain and release on an autoreleased object as normal

              [foo release];
              // Calling an 'unbalanced release' like this will cause a crash
              // at some unknown point in the future
            ```
          - >
            Different classes in Cocoa / Objective C have different rules about how they retain objects.  The documentation is instructive in telling you what memory management semantics you should expect from given functionality.

            <% block("Mac Programmers Have All The Luck") do %>
              Should you be programming Mac OS applications as opposed to iOS applications, you can take advantage of garbage collection memory management which has been available since Mac OS Leopard (10.5); iOS programmers still have to manage their
              memory themselves, however.
            <% end %>
    - "Properties":
        slides:
          - >
            Much of the interaction with Objective C objects equates to the usual getter/setter functionality commonly associated with Object Oriented Programming. To make it easier for programmers to declare this functionality, properties were introduced as a way to eschew all the boilerplate code and provide a common framework upon which to enhance Objective C objects.
          - >
            # Property interface declaration

            ```objectivec
              @interface MyObject : NSObject {
                NSString * instanceVariable;
                float numericVariable;
              }
              @property(readwrite, retain) NSString * instanceVariable;
              @property(readonly, assign) float numericVariable;
              @end

              @implementation MyObject

              @synthesize instanceVariable;
              @synthesize numericVariable;

              -(void) dealloc {
                [instanceVariable release];
                [super dealloc];
              }

              @end
            ```
          - >
            # Property usage

            ```objectivec
              MyObject * mo = [[MyObject alloc] init];
              [mo setInstanceVariable:@"Test"];
              [mo setNumericVariable:20.0f];
              NSLog(@"The values I set were %@ and %f",
                      [mo instanceVariable],
                      [mo numericVariable]);
            ```
          - >
            You can specify the memory management semantics (retain, assign, copy) in the property declaration.  You can also specify the atomicity (locking behavior) of the property, and more.

            <% block("More to it..") do %>
              Properties do not merely provide getter/setter functionality.  The use of properties also implicitly adds Key-Value-Observing functionality to your class, letting you automatically monitor classes for change events and performing specific code in such cases.  Read more at <%= url("http://developer.apple.com/mac/library/documentation/cocoa/conceptual/objectivec/articles/ocProperties.html") %>.
            <% end %>
    - "Selectors":
        slides:
          - >
            Selectors in Objective C are a way to provide a special type to indicate a message. They allow you to dynamically send a message to an object, as well as to query an object to see if it responds to a given message.
          - >
            # Selector usage

            ```objectivec
              SEL aSelector = @selector(length);
              NSString * foo = @"Foo";
              if([foo respondsToSelector:aSelector]){
                NSLog(@"The length of foo is %i",  [foo performSelector:aSelector]);
              }
            ```
          - >
            # Other selector usage

            Selectors can be built from strings, and can refer to any Objective C message that is forwarded to an object.

            ```objectivec
              NSString * aUserSuppliedString = MagicallyGetStringFromUserInput();
              SEL aSelector = NSSelectorFromString(aUserSuppliedString);
              if([someObject respondsToSelector:aSelector]){
                // NOTE: Surely nothing bad will happen
                [someObject performSelector:aSelector];
              }
            ```
    - "Protocols":
        slides:
          - >
            Objective C provides only single-inheritance for its objects; to allow for situations where a class may provide functionality outside of its inheritance chain, the language provides Protocols, which are roughly analogous to interfaces in Java and C\#.  There are informal protocols (only referred to in documentation) and formal protocols, which are compiler checked.  The majority of protocol usage in iOS programming is formal protocols.
          - >
            # Protocol declaration

            ```objectivec
              @protocol TestProtocol

              -(void) definitelyHasThisMethod;

              @optional

              -(void) mayHaveThisMethod;

              @end

              @interface SomeObject : NSObject<TestProtocol> {

              }

              @end
            ```
          - >
            # Protocol usage

            ```objectivec
              SomeObject<TestProtocol> * oo = [[SomeObject alloc] init];

              // We assume this because the object conforms to TestProtocol
              [oo definitelyHasThisMethod];

              if([oo respondsToSelector:@selector(mayHaveThisMethod)]){
                [oo mayHaveThisMethod];
              }
            ```
    - "Categories":
        slides:
          - >
            Categories allow you to mix in new code to existing classes without having to change the original source code for those classes.  Examples of categories include automatically adding special serialization rules to NSObject, or special data structure Queue behavior to Cocoa collection classes.

            <% alertblock("Except for..") do %>
              You can't add instance variables to a class with categories; they are purely for adding new methods to a class, but cannot change the memory layout of a class after the fact.
            <% end %>
          - >
            # Category declaration

            ```objectivec
              @interface NSString(FunkyStrings)

              -(NSString *) getFunky;

              @end

              @implementation NSString(FunkyStrings)

              -(NSString *) getFunky {
                return [self stringByAppendingString:@"...YEAH! ALL RIGHT! FEELS GOOD!"];
              }

              @end
            ```
          - >
            # Category usage

            ```objectivec
            #import "NSString+FunkyStrings.h"

            void main(){
              NSLog(@"The funkiest string by far is %@", [@"James Brown" getFunky]);
            }
            ```
    - "Review common useful classes in Objective C / Cocoa to accomplish certain tasks":
        slides:
          - >
            There are a host of useful classes in the Cocoa Touch framework that provide special functionality to you.  Some of the more common objects you'll use in your programming are NSArray, NSDictionary, NSNumber and NSString.  Each of these objects have mutable versions that allow you to modify them after instantiation.
          - >
            # NSString usage

            NSString is an enhanced, unicode aware string class that goes far beyond the simple byte-array behavior of C's byte-array strings.

            ```objectivec
              NSString * s = [[NSString alloc] initWithCString:"this is an ascii string"
                                               encoding:NSASCIIStringEncoding];
              NSMutableString * so = [[NSMutableString alloc]
                                              initWithString:@"A mutable string with..."];

              [so appendString:s];

              NSLog(@"The mutable string is %@", so);

              [so release];
              [s release];
            ```
          - >
            # NSNumber usage

            NSNumber is a simple abstract wrapper around numeric values which allows you to automatically convert its held value to the appropriate form, as well as having an object-like representations of a numeric value.

            ```objectivec
              NSNumber * n = [[NSNumber alloc] initWithFloat:20.0f];
              double d = [n doubleValue];
              int i = [n intValue];
              [n release];
            ```
          - >
            NSDictionary is a generic dictionary object that you can use to hold key/value associations. A key can be any NSObject that responds to isEqual: and NSCopying; in most cases, your keys will be either NSString or NSNumber objects.
          - >
            # NSDictionary usage

            ```objectivec
              NSDictionary * a = [[NSDictionary alloc] initWithObjectsAndKeys:
                                                    @"The foo string", @"Foo",
                                                    @"The bar string", @"Bar",
                                                    nil];

              NSMutableDictionary * b = [[NSMutableDictionary alloc] init];
              [b setObject:@"Another string" forKey:[NSNumber numberWithInt:20]];

              NSLog(@"a's alue for Foo is %@, and b's value for 20 is %@",
                                        [a objectForKey:@"Foo"],
                                        [b objectForKey:[NSNumber numberWithInt:20]]);

              for(id key in a){
                NSLog(@"The value for %@ is %@", key, [a objectForKey:key]);
              }

              [b release];
              [a release];
            ```
          - >
            # NSArray usage

            NSArray is a simple way to collect NSObject inheriting classes into a sequential list.  NSArray automatically retains each object added to it, and releases each object it holds once its own retain count has reached 0.

            ```objectivec
              NSArray * a = [[NSArray alloc] initWithObjects:@"Foo", @"bar", @"baz", nil];
              NSMutableArray * b = [[NSMutableArray alloc] init];
              [b addObject:@"Not foo"];
              NSLog(@"The contents of a are %@ and b are %@", a, b);

              for(NSString * obj in a){
                NSLog(@"The array contains %@", obj);
              }

              [a release];
              [b release];
            ```
          - >
            NSArray, NSDictionary, NSString and NSNumber may all be represented by the contents of a property list file ( Plist ).  You can easily rebuild an NSArray or NSDictionary full of the property list contents by using the initialization method `initWithContentsOfFile:`
          - >
            # Property List Deserialization

            <% figure("Sample Property List") do %>
              <%= graphic("PListExample1.png", 0.5) %>
            <% end %>

            ```objectivec
              NSDictionary * example = [[NSDictionary alloc]
                                           initWithContentsOfFile:@"/path/to/sample.plist"];
              NSLog(@"The subarray contents are %@",
                         [example objectForKey:"A subarray of values"]);
              [example release];
            ```
    - "More learning":
        slides:
          - >
            Objective C is a rich, deep language.  There are lots of resources on the web and your computer where you can learn more. The best is easily the XCode documentation, but there are blogs out there that can provide invaluable help: Mike Ash's [NSBlog](http://www.mikeash.com/pyblog/),  [Cocoa With Love](http://cocoawithlove.com/) , and the [Apple Developer Forums](http://developer.apple.com/devforums/) can all provide invaluable help in learning new techniques and advanced usage for your apps.
  - "iPhone App Layout Conventions":
    - "MVC, as applied to an app":
        slides:
          - >
            Apple strongly encourages you to adhere to Model View Controller pattern
    - "Application -> Window -> View Controller(s) -> View(s) + Models":
        slides:
          - >
            On iOS, a UIApplication ( your app ) typically has one UIWindow, which is the primary UIView upon which everything else displays.  A UIView is just a rectangle upon which you draw things.
          - >
            Almost everything visual is a UIView (except the things that aren't).
          - >
            <% figure("UIViews are everything") do %>
              <%= graphic("UIViewExample.pdf", 0.35) %>
            <% end %>
          - >
            <% figure("UIViews are almost everythign") do %>
              <%= graphic("UIViewExample2.pdf", 0.35) %>
            <% end %>
          - >
            UIViewControllers are objects that manage what the views on screen are currently doing; typically where you write event handling code and user interaction code.
          - >
            You provide the model
    - "UINavigationController":
        slides:
          - >
            UINavigationController is a stack based manager of view controllers that the user can navigate through
          - >
            <% figure("Items managed by UINavigationController ") do %>
              <%= graphic("UIViewExample3.pdf", 0.35) %>
            <% end %>
          - >
            Every UIViewController managed by a UINavigationController has a reference to that UINavigationController
          - >
            # Adding another UIViewController to the UINavigationController stack

            ```objectivec
              MyViewController * controller = [[MyViewController alloc] initWithNibName:nil
                                                                        bundle:nil];
              [[self navigationController] pushViewController:controller animated:YES];
              [controller release];
            ```
    - "Lab 2":
        slides:
          - >
            Create a new View based project
          - >
            Add a UINavigationController to MainWindow.xib
          - >
            Create a new view controller
          - >
            Add a button to the first view controller and create an action to open the second view controller
    - "UITabBarController and UITableViewController":
        slides:
          - >
            UITabBarController swaps in UIViewControllers assigned to it when users click on the associated button
          - >
            Each UIViewController has a tabBarItem property that UITabBarController uses to populate its UITabBar
          - >
            <% figure("UITabBarController example") do %>
              <%= graphic("UIViewExample4.pdf", 0.30) %>
            <% end %>
          - >
            UITableViewController instructs a UITableView about the number of rows it contains, what to do when clicked, the number of sections, and other information
          - >
            UITableViewController is just a convenience class that saves you from manually conforming an object to the UITableViewDataSource and UITableViewDelegate protocols
          - >
            <% figure("UITableView example") do %>
              <%= graphic("UIViewExample5.pdf", 0.30) %>
            <% end %>
    - "Lab 3":
        slides:
          - >
            Add a UITableViewController to the project
          - >
            Add an NSArray containing names from the class to the controller
          - >
            Change the Interface builder reference to the UITableViewController
    - "Modal view controllers":
        - >
          Not all view controllers fit within the "display in UINavigationController" or "display in UITabBarController"
          model.
        - >
          <% figure("UIImagePickerController") do %>
            <%= graphic("UIViewExample6.pdf", 0.35) %>
          <% end %>
        - >
          <% figure("MFMailComposeViewController") do %>
            <%= graphic("UIViewExample7.pdf", 0.35) %>
          <% end %>
        - >
          # Presenting a view controller modally

          You can present a view controller modally by using the `presentModalViewController:animated:` message

          ```objectivec
            -(IBAction) buttonClicked:(id) sender {
              MyViewController * mvc = [[MyViewController alloc]
                                             initWithNibName:@"TheNib"
                                             bundle:nil];
              [self presentModalViewController:mvc animated:YES];
              [mvc release];
            }
          ```
        - >
          You can specify the transition style with which the view controller appears via the UIViewController message `setModalTransitionStyle:(UIModalTransitionStyle)style`
  - "XCode and Interface Builder":
    - "Capabilities":
        slides:
          - >
            XCode and Interface Builder combined provide a development, debugging and interface development tool for you to develop your iPhone apps.  It can integrate with SVN, CVS or Perforce ( and soon, Git! ), it can run automated tests on your code, provide inline documentation assist, code completion and a lot more. It also provides a developer level interface to all the devices you will be debugging your code on; you can manage devices and device profiles through XCode as necessary.
    - "Creating an app":
        slides:
          - >
            XCode provides a number of application templates for starting an app.  Most basic types of applications can get a fast start by using one of these app templates.
            <% figure("XCode New Project window") do %>
              <%= graphic("ProjectCreator.png", 0.35) %>
            <% end %>
          - >
            Once you've selected the type of app you want to create, your project will be created with an application delegate and usually at least one view controller that will manage what goes on the screen.  It will also have a .xib file for your application, and for each view controller in the app, that is used by Interface Builder to layout the screen contents.
            <% figure("New Project File List") do %>
              <%= graphic("ProjectFileList.png", 0.75) %>
            <% end %>
            <% block("The application delegate - UIApplicationDelegate") do %>
              The application delegate ( UIApplicationDelegate protocol ) is the class which will respond to overall application lifecycle events, like when your application has started, resumed from suspension, or is about to shut down.
            <% end %>
          - >
            Double clicking on a .xib file will open it in Interface Builder, where you can drag components from the Interface Builder toolbox into the view.  You can easily change the orientation of objects.
    - "Documentation usage":
        slides:
          - >
            <%= highlight("Help - Developer Documentation") %> is an invaluable resource for researching Cocoa internals.
    - "Protips!":
        slides:
          - >
            Learn hotkeys! ( CMD+SHIFT+D  and CMD+0 will buy you hours )
          - >
            Make XCode fit you ( Single window interface, XCode themes, application templates )
          - >
            XCode plugins ( Code Pilot <%= url("http://mac.brothersoft.com/code-pilot-for-xcode.html") %>, Accessorizer <%= url("http://www.kevincallahan.org/software/accessorizer.html") %> )
  - "Questions"
- subtitle: "Day 2"
  title: "iOS Application Development"
  author: "Chris Zelenak"
  date: "12/03/2013"
  sections:
  - "Images":
    - "The UIImage":
        slides:
          - >
            A way to represent a bytestream
          - >
            Does NOT give you access to the underlying image data
          - >
            Can be made from any given iPhone UI screen
          - >
            Carries with it a lower level CGImageRef object
            <% code_block("objectivec") do %>
              CGImageRef theImage = [aUIImage CGImage];
            <% end %>
          - >
            Can be loaded in cache form with
            <% code_block("objectivec") do %>
              UIImage * img = [UIImage imageNamed:@"ImageFilename.png"];
            <% end %>
            or loaded in no-cache form with
            <% code_block("objectivec") do %>
              NSBundle * bnd = [NSBundle mainBundle];
              NSString * path = [bnd pathForResource:@"ImageFilename" ofType:@"png"];
              UIImage * img = [[UIImage alloc] initWithContentsOfFile:path];
            <% end %>
          - >
            UIImage can handle most basic image types: PNG, JEPG, GIF, ICO, BMP, TIF..
          - >
            But the fastest way to load and draw images will typically be with PNGs.
    - "UIImageView and UIButton":
        slides:
          - >
           UIImageView provides a simple way to put an image on the screen, w/ no interaction
          - >
            <% code_listing("Loading a UIImageView with an image", "objectivec") do %>
              UIImageView * v = [[UIImageView alloc]
                                  initWithFrame:CGRectMake(0.0, 0.0, 200.0, 200.0)];
              UIImage * someImage = [UIImage imageNamed:@"screenImage.png"];
              [v setImage:someImage];
              [someView addSubview:v];
              [v release];
            <% end %>
          - >
            UIButton can also show an image instead of a rounded rectangle.  It can display different
            images for both foreground and background based on its current state as well.
          - >
            <% code_listing("Loading a UIButton with an image", "objectivec") do %>
              UIButton * b = [UIButton buttonWithType:UIButtonTypeCustom];
              [b setImage:[UIImage imageNamed:@"btnImage.png"]
                 forState:UIControlStateNormal];
              [b setBackgroundImage:[UIImage imageNamed:@"btnImageSelectedBG.png"]
                           forState:UIControlStateSelected];
              [someView addSubview:b];
            <% end %>
    - "Lab 4":
        slides:
          - >
            Create a detail UITableViewController
          - >
            Load in class images in header with student name
          - >
            Push UITableViewController onto UINavigationController stack
  - "More about UIView and Core Graphics":
    - "What comes with UIView":
        slides:
          - >
            Any UIView can have its background color, overall opacity,  dimensions and overall coordinate transform (CGAffineTransform)
          - >
            Any UIView can contain any number of subviews
          - >
            Any UIView can have specific autoresizing behavior applied to it when its parent view changes
          - >
            Any UIView can automatically resize its subviews when its dimensions change
          - >
            Any UIView subclass can choose to respond to direct touch events
          - >
            Any UIView can optionally choose to blit its contents directly to the screen with Core Graphics
    - Views and subviews:
        slides:
          - >
            The subviews a UIView has are contained within the subviews property of a view
          - >
            You can see the subviews of a view layed out in Interface Builder by expanding the View in the Document view
            <% figure("Expanding the contents of a UIView") do %>
              <%= graphic("UIViewExpand.png", 0.5) %>
            <% end %>
          - >
            Views overlay each other based on the order they are added to the parent view; you can swap their order by using
            UIView methods like
            <% code_block("objectivec") do %>
              -(void) bringSubviewToFront:(UIView *)view;
              -(void) sendSubviewToBack:(UIView *)view;
              -(void) exchangeSubviewAtIndex:(NSInteger)idx withSubviewAtIndex:(NSInteger)idx;
            <% end %>
    - "Events and control events":
        slides:
          - >
            Any UIView subclass can override the methods

            <% code_listing("Touch events", "objectivec") do %>
              - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;
              - (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;
              - (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;
              - (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;
            <% end %>

            and perform their own logic when the view is touched.
          - >
            The NSSet passed to each of the event handling methods is full of
            UITouch objects, which can give you information about where specifically
            in a view the touch occurred.

            <% alertblock("Multi-touch") do %>
              If you want to provide multi-touch interactivity with your view,
              ensure that you have set the multipleTouchEnabled property of your
              view to YES.
            <% end %>
          - >
            UIControl objects ( like UIButton ) offer more flexibility for responding
            to events by allowing you to assign specific selectors to be called
            at specific touch event times.

            <% code_listing("Handling UIButton events", "objectivec") do %>
              UIButton * b = [UIButton buttonWithType:UIButtonTypeCustom];
              [b addTarget:self action:@selector(wasTouched:)
                 forControlEvents:UIControlEventTouchDown];
              [b addTarget:self action:@selector(wasDraggedOut:)
                 forControlEvents:UIControlEventTouchDragOutside];
            <% end %>
    - "Position, size and color of views - CGRect, CGPoint, CGSize, UIColor":
        slides:
          - >
            Each UIView has a bounding frame and origin coordinate that specifies where
            in the parent view it appears; this is represented by a CGRect, which is a
            combination of CGPoint and CGSize .
          - >
            CGRect, CGPoint and CGSize are all simple C-structs; they each have simple
            C constructor methods which make working with them easier:
            <% code_listing("CG struct constructor methods", "objectivec") do %>
              CGRect myFrame = CGRectMake(0.0, 0.0, 200.0, 128.0);
              CGPoint myPoint = CGPointMake(0.0, 10.0);
              CGSize mySize = CGSizeMake(200.0, 128.0);
            <% end %>
          - >
            They are used universally throughout UIKit whenever ascertaining the
            location or dimensions of an object need to be queried.
          - >
            The CGAffineTransform of a view modifies the /at render time/ value
            of coordinates, not the logical value you've assigned.
          - >
            UIColor can be used to specify any common color value combination
            you wish to apply to an object.
          - >
            UIColor provides a host of simple convenience methods for accessing
            commonly used colors.

            <% code_listing("UIColor usage", "objectivec") do %>
              UIColor * c = [UIColor blackColor];
              UIColor * oc = [UIColor colorWithRed:1.0
                                             green:0.0
                                              blue:0.0
                                             alpha:0.75];
              UIImage * pattern = [UIImage imageNamed:@"myTileImage.png"];
              UIColor * pt = [UIColor colorWithPatternImage:pattern];
            <% end %>
    - "drawRect:":
        slides:
          - >
            Some effects aren't easily achieved through UIViews and drawn images.  To
            draw your view components manually, you can override the drawRect method
            and manually blit your graphics to the screen.
          - >
            When drawing your graphics manually, you need to acquire a handle to the
            graphics surface.  In Core Graphics, this is the CGContextRef, and you can
            get a handle to it by using UIKit to get the current valid context.

            <% code_listing("Core Graphics context", "objectivec") do %>
              -(void) drawRect:(CGRect) frame {
                CGContextRef context = UIGraphicsGetCurrentContext();
                CGContextSetFillColor(context, [[UIColor redColor] CGColor]);
                CGContextFillRect(context, frame);
              }
            <% end %>
  - "UIView Animation":
    - "UIView beginAnimations / commitAnimations":
        slides:
          - >
            You can easily use Core Animation to animate any of your
            UIViews by using the beginAnimations  and commiteAnimations messages.
          - >
            <% code_listing("Example animation", "objectivec") do %>
              [UIView beginAnimations:nil context:NULL];
              [someView setAlpha:0.0];
              [UIView commitAnimations];
            <% end %>
          - >
            Most properties that affect a view's appearance are able to be animated,
            including size, position, arrangement with respect to other subviews  and transparency.
    - "Controlling the animation":
        slides:
          - >
            You can set special properties for the animation inside the animation block.
            These properties include duration, animation curve, delay for animation and
            completion callbacks.
          - >
            The animation curve specifies the easing behavior of an animation - you can set the
            animation to be linear, ease in, ease out or ease in and out.
            <% code_listing("Setting easing behavior", "objectivec") do %>
              [UIView beginAnimations:nil context:NULL];
              [UIView setAnimationCurve:UIViewAnimationCurveEaseOut];
              [someView setFrame:CGRectMake(newX, newY, newWidth, newHeight)];
              [UIView commitAnimations];
            <% end %>
          - >
            The animation duration and delay indicate how long the animation will run,
            and how long the animation will wait before running, respectively.
            <% code_listing("Setting duration and delay", "objectivec") do %>
              [UIView beginAnimations:nil context:NULL];
              [UIView setAnimationDuration:12.0]; // 12 sec
              [UIView setAnimationDelay:1.0]; // wait 1 sec before playing
              [someView setAlpha:0.45];
              [UIView commitAnimations];
            <% end %>
          - >
            You can specify a delegate to receive start and stop selectors when the animation
            first begins and when the animation ends as well.
          - >
            <% code_listing("Handling animation start/stop events", "objectivec") do %>
              -(void) beginAnimation {
                [UIView beginAnimations:nil context:(void *)theView];
                [UIView setAnimationDelegate:self];
                SEL didStop = @selector(animDidStop:finished:ctxt:);
                SEL wilLStart = @selector(animWillStart:finished:ctxt:);
                [UIView setAnimationDidStopSelector:didStop];
                [UIView setAnimationWillStartSelector:willStart];
                [theView setAlpha:0.0];
                [UIView commitAnimations];
              }
            <% end %>
          - >
            <% code_listing("Handling animation start/stop events pt. 2", "objectivec") do %>
                -(void) animWillStart:(NSString *)animid
                                 ctxt:(void *)context {
                  NSLog(@"Started fade out");
                }

                -(void) animDidStop:(NSString *)animid
                           finished:(BOOL)finished
                               ctxt:(void *)context {
                  UIView * v = (UIView *) context;
                  [v removeFromSuperview];
                  NSLog(@"Removed faded view");
                }
            <% end %>
    - "Lab 5":
        slides:
          - >
            Create a UITableViewCell subclass
          - >
            Add a front and back image view to the UITableViewCell
          - >
            Properly use the new cell subclass in the detail view controller
          - >
            Add an image swap method to the subclass
          - >
            Swap the images when touched
          - >
            Correctly adjust the cell text to make room for the new image
  - "UIView and CALayer - Coordinate systems, layer backing":
    - "UIViews each containing a layer":
        slides:
          - >
            Each UIView contains an object called a CALayer; this layer
            represents the final output of the view to be rendered to
            screen.
          - >
            The CALayer object of a UIView may contain sublayers.
            The tree hierarchy of UIViews is functionally identical
            to the tree hierarchy of CALayers.
          - >
            The coordinate system of a UIView is not identical to the
            coordinate system of a CALayer.
    - "The contents attribute of a CALayer":
        slides:
          - >
            Each CALayer has a property called contents which is intended
            to hold a CGImageRef.
          - >
            Alternatively, a CALayer may have a delegate assigned to it,
            whose job it is to render content to a supplied CGContextRef.
          - >
            The layer that is created for each UIView has its delegate
            assigned to that UIView.
    - "How the above animation actually occurs under the hood ( brief reference to CATransaction )":
        slides:
          - >
            CALayers are the lower level manifestation of UIView animation.
          - >
            The animation calls at the UIView level boil down to operations
            inside a CATransaction.
          - >
            CATransactions imply batch operations upon a known "current state"
            of a CALayer; once the transaction has been committed,
            the values will be changed for the duration of the
            CATransaction on the modelLayer of a layer, and flushed to the
            presentationLayer.
    - "Similarities and differences between a CALayer and a UIView":
        slides:
          - >
            Both have transform properties; CGAffineTransform for UIView,
            CATransform3D for CALayer. CALayer allows for simple depth changes
            to a given layer's contents.
          - >
            The origin for CALayer's is centered; the origin for UIViews is
            at the upper left of the view.
          - >
            CALayers have no input model to speak of; CALayer subclasses
            need to be explicitly notified of user input.
    - "Reference to CATiledLayer and performance optimizations":
        slides:
          - >
            CALayers abstract how image content is batched to the graphics
            subsystem.  With large ( greater than 2048x2048 ) image content, it becomes
            necessary to partition the content into smaller chunks.
          - >
            CATiledLayer lets you build Google Maps style tiling of
            images into manageable chunks for the graphics hardware.
          - >
            Automatically computes the desired tile size for a given
            display areo and zoom level.
  - "Questions"
- subtitle: "Day 3"
  title: "iOS Application Development"
  author: "Chris Zelenak"
  date: "12/04/2013"
  sections:
    - "Core Data and SQLite":
      - "NSManagedObject and beyond":
          slides:
            - >
              NSManagedObject is the primary element of working with your core
              data store. It represents a single entity's worth of information
              in the database that backs your app. The actual data for the
              entity is able to be queried via the valueForKey and setValue:forKey:
              methods of NSManagedObject.
            - >
              NSManagedObject changes are queued to an NSManagedObjectContext
              which is roughly equivalent to a database transaction; it provides
              locking, commit/rollback and undo/redo functionality for
              object changes.
            - >
              NSEntityDescription describes the schema associated with
              a specific type of NSManagedObject; a database table is similar
              in the way that it describes the layout of its child rows.
            - >
              NSManagedObjectModels are created by the programmer, and are
              collections of NSEntityDescriptions.
            - >
              NSPersistentStore represents the actual physical location of
              your Core Data objects, and can be a database, an XML file,
              or any other other physical manifestation of data for
              which an NSPersistentStore has been written.
            - >
              You can create your own NSManagedObjectModel subclasses that
              provide convenient abstractions over NSManagedObjectModel.
            - >
              To get an instance of an NSManagedObject that is able to be
              saved to the NSPersistentStore, use:

              <% code_listing("Getting a new NSManagedObject that will eventually be saved to an NSPersistentStore", "objectivec") do %>
                NSManagedObject * newObject = [NSEntityDescription
                                               insertNewObjectForEntityForName:@"EntityName"
                                               inManagedObjectContext:managedObjectContext];
              <% end %>
            - >
              To save changes to all current NSManagedObjects currently managed
              by an NSManagedObjectContext:

              <% code_listing("Saving changed objects", "objectivec") do %>
                NSError * error = nil;
                [managedObjectContext save:&error];
                if(error){
                    NSLog(@"Couldn't save objects, %@", error);
                }
              <% end %>
      - "NSPredicate and NSFetchRequest":
          slides:
            - >
              Actually fetching objects from the Core Data store requires you
              to build queries using NSPredicate or NSFetchRequest.
            - >
              The syntax for NSPredicate and NSFetchRequest requests is
              similar to SQL, but not identical.
            - >
              <% code_listing("NSPredicate example", "objectivec") do %>
                NSPredicate * searchPredicate = [NSPredicate
                                         predicateWithFormat:@"(firstName = 'Chris') AND "
                                                      @"(lastName BEGINSWITH 'Zel') AND "
                                                      @"(age BETWEEN {%i,%i})", 20, 30];
              <% end %>
              <% block("See more..") do %>
                Read more about writing NSPredicates in the "Predicate Programming Guide" in
                the XCode documentation.
              <% end %>
            - >
              You can also build named NSFetchRequests in the .xcdmodel
              for your entities.
              <% figure("Predicate builder") do %>
                <%= graphic("PredicateBuilder.png", 0.5) %>
              <% end %>
            - >
              <% code_listing("Stored NSPredicate example", "objectivec") do %>
                NSFetchRequest * req = [managedObjectModel
                                         fetchRequestFromTemplateWithName:@"requestByName"
                                         substitutionVariables:[NSDictionary
                                            dictionaryWithObjectsAndKeys:
                                              @"Pwnsberry", @"LAST_NAME", nil]];
              <% end %>
      - "Lab 6":
          slides:
            - >
              Create a property list with the names of the students in the class
            - >
              Create the xcdmodel that describes the entities
            - >
              Initialize the Core Data persistence layer
            - >
              Use NSUserDefaults to detect whether or not the app has been started before
            - >
              Perform the import if the app has never been started before
            - >
              Pass the user and image data on to the details controller
    - "Networking ( NSURLRequest )":
      - "NSURL, NSURLRequest,  NSMutableURLRequest AND NSURLConnection":
          slides:
            - >
              NSURL is meant to only represent a single resource location
            - >
              NSURL can be allocated to represent either a filesystem location,
              or a web resource
            - >
              NSURLRequest and NSMutableURLRequest represent specific
              web resources that you'd like to initiate a connection to;
              NSURLRequest should be used for simple GET HTTP requests,
              while NSMutableURLRequests can be used for more complex
              HTTP requests.
            - >
              NSMutableURLRequest allows you to set HTTP headers,
              the HTTP method used, and the request body.
            - >
              NSURLRequest and NSMutableURLRequest both by default
              only work with HTTP requests
            - >
              NSURLConnection initiates the download and returns
              the NSHTTPURLResponse which contains the body of the
              response, as well as http status code and
              response headers.
            - >
              NSURLConnection can send data both synchronously
              or asynchronously; the response information is passed
              back to the connection delegate via the
              informal NSURLConnection delegate.
      - "Networking Lab":
          slides:
            - >
              Create a new UIVIewController
            - >
              Add an NSURLConnection object
            - >
              Download the plist object and deserialize it
            - >
              Load the tableView with the new data
      - "( ASIHttpRequest, EasyURLDownloader )":
          slides:
            - >
              ASIHttpRequest gives you a full-featured HTTP library
              enhancement; cookie persistence support, enhanced
              HTTP auth support, S3 support and more.
              <%= url("http://github.com/pokeb/asi-http-request/") %>
            - >
              EasyURLDownloader gives you a simple library to
              perform asynchronous GET downloads in the background
              <%= url("http://github.com/netshade/EasyUrlDownloader") %>
      - "SOAP and REST Webservices":
          slides:
            - >
              You can roll your own webservice access, but you
              don't have ot.
            - >
              ObjectiveResource makes accessing REST services
              with ObjectiveC incredibly easy.
            - >
              WSMakeStubs will create stubs for you that shim out
              the available endpoints of a WSDL web service.
            - >
              ObjectiveResource is available at
              <%= url("http://github.com/yfactorial/objectiveresource") %>
            - >
              WSMakeStubs is a binary included with your SDK
    - "Getting your application on the device":
      - "Development certificates, Distribution certificates":
          slides:
            - >
              Log in to the iPhone developer portal and request a developer certificate
            - >
              Explain Key requests
            - >
              Download and install certificate
            - >
              Create development provisioning profile with devices
            - >
              Assign development provisioning profile
            - >
              AdHoc and Store based distribution reserved for Agents only
    - "Using Instruments":
      - "Always, always, always memory leak check":
          slides:
            - >
              Opening up the Leaks tool and examining your application behavior
            - >
              Examining specific leaks
            - >
              Understanding the Leaks tool
      - "Always, always, always activity monitor check":
          slides:
            - >
              Using Activity Monitor to monitor your current system state
    - "Distributing your app to others":
      - "The process you need to know":
          slides:
            - >
              Releasing your app to others in beta form
            - >
              What is an .ipa file
            - >
              How to send your .ipa file to others
      - "The URLs you need to know":
          slides:
            - >
              <%= url("http://developer.apple.com/iphone/") %> is the frontend to most
              Apple web services
            - >
              <%= url("http://itunesconnect.apple.com/") %> is the URL to access the app-release
              frontend and store management services provided by Apple
    - "Questions"
- subtitle: "Day 4"
  title: "iOS Application Development"
  author: "Chris Zelenak"
  date: "12/05/2013"
  sections:
    - "Overview of what's new in 4.0":
      - "Multitasking"
      - "Event Kit"
      - "Core Motion"
      - "Data Protection"
      - "Core Telephony"
      - "Assets Library"
      - "Quick Look framework"
      - "AVFoundation update"
      - "ImageIO"
      - "CoreMedia"
      - "CoreVideo"
    - "Hardware differences between devices":
      - "iPhone 2G"
      - "iPod Touch models"
      - "iPhone 3G"
      - "iPhone 3GS"
      - "iPad"
      - "iPhone 4"
    - "Device coordinate systems, logical points vs. physical pixels":
      - "Mapping points to pixels"
      - "Image naming schemes"
      - "iPad v. iPhone 4 v. iPhone earlier naming schems"
    - "Blocks in Objective C":
      - "Overview of blocks wrt function closures"
      - "Use of blocks in new iOS"
    - "Multiprocessing, Grand Central Dispatch":
      - "Use of blocks and queues in GCD"
    - "Accelerate":
      - "Preparing your application for iOS 4.0"
    - "Multitasking aware"
    - "Class overview, bits of information that didn't fit anywhere else"
    - "Thanks!"
- subtitle: "Day 5"
  title: "iOS Application Development"
  author: "Chris Zelenak"
  date: "12/06/2013"
  sections:
    - "New Stuff"
