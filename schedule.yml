presentations:
- subtitle: "Day 1"
  title: "iOS Application Development"
  author: "Chris Zelenak"
  date: "12/02/2013"
  sections:
  - "Intro to class":
      notes:
        - >
          Welcome to the 4-Day iOS Application Development class.
          Over the course of these next 4 days, we're going to be
          reviewing Objective C, UIKit, Core Animation, Core Data,
          and a host of other technologies you may only know by name.
        - >
          Email me two pictures of you - one serious and one silly - to  chris - at - fastestforward.com
  - "Lab 1":
    - "Create a new iPhone Project":
        notes:
          - >
            Create a new View based application in XCode called Lab1
          - >
            Open Lab1ViewController.xib in Interface Builder
    - "Add a button":
        notes:
          - >
            Add a button with the text "Hello iPhone"
    - "Connect the button to the view controller":
        notes:
          - >
            Add an IBAction selector to the view controller
          - >
            Make it open an alert view
    - "Build and run in simulator":
        notes:
          - >
            Yay!
  - "Objective C":
    - "Overview":
        notes:
          - >
            Objective C is a superset of C. It tacks on to C a message-passing
            object model similar to Smalltalk's (see Ruby), with a reflective
            class model built in.
          - >
            In a more understandable form, Objective C allows you to use weak
            and dynamicly typed language features along with the static typing
            of C; it also allows you to take advantage of runtime method
            resolution, so that your object's implementation of certain messages
            may be determined at call-time rather than at compile-time.
          - >
            The language is still physically identical to C in many ways, in that
            the bulk of your development will be alternating between
            header files (.h files) and implementation files (.m files). You will
            also be doing a lot of memory management, which may fill you with
            either fear or joy, depending on your experience with garbage
            collected languages.
          - >
            You will also be dealing a lot with many other C-family familiars,
            such as enumerated integer constants (enums), structs, pass-by-reference v.
            pass-by-value semantics and pointers.  You don't need to have a
            very strong grasp on these things immediately, but the more iPhone programming
            and Objective C programming you do, the more your skills will benefit
            from a firm grasp of C.
    - "Review of standard C elements":
        notes:
          - >
            These are items you'll commonly encouter while doing iPhone programming
            whose roots belong in the C family:
            <% code_listing("C Language elements - Enumerations", "c") do %>
              typedef enum {
                NONE = 0,
                SOME,
                ALL
              } ThoseWhoPreferItHot;

              ThoseWhoPreferItHot = SOME; // Use of enumerated constant
            <% end %>
          - >
           <% code_listing("C Language Elements - Structs", "c") do %>
              // Declaring a point in space type
              typedef struct {
                float x;
                float y;
              } APointInSpace;

              APointInSpace point;
              point.x = 20.0;
              point.y = 410.0;

              // C99 style struct instantiation
              APointInSpace point2 = { .x= 21.0, .y=32.0 };
           <% end %>
          - >
           <% code_listing("C Language Elements - Arrays and Pointers", "c") do %>
              // a constant byte array
              char * constantCharArray = "Or in other words, a string";

              // C99 style array instantiation
              int aListOfNumbers[5] = { 1, 2, 3, 4, 5 };
              int aListOfNumbers[] = { 1, 2, 3, 4, 5};

              // C99 Variable length array declaration
              float aListOfFloats[someQualifier];

              // pointer declaration to NULL
              int * someIntegerPtr = NULL;
              int someInteger = 5;

              // address dereference
              someIntegerPtr = &someInteger;
            <% end %>
          - >
            If you've not kept abreast of changes between ANSI-92 C (a common version of C
            taught in universities and in many books about C) and C99, read more at
            <%= url("http://home.datacomm.ch/t_wolf/tw/c/c9x_changes.html") %>
            <%= bibliography("C99Changes", "http://home.datacomm.ch/t_wolf/tw/c/c9x_changes.html") %>.
    - "Syntax":
        notes: >
          <% code_listing("Some typical Objective C code", "objectivec") do %>
            NSString * anExampleString = @"This is a pointer to an NSString object";
            int strLen = [anExampleString length];

            NSString * aSecondString = [anExampleString
              stringByAppendingString:@" that had a second string appended to it"];

            if([anExampleString
                 compare:@"this is a pointer to an nsstring object"
                 options:NSCaseInsensitiveCompare] == NSOrderedSame){
              NSLog(@"The string %@ was case insensitive equal", anExampleString);
            }
          <% end %>
    - "Calling functions":
        notes: >
          Given some Objective C object, like:

          <% code_block("objectivec") do %>
            NSString * anObject = @"TheObject";
          <% end %>

          you can invoke functionality on that object via the form:

          <% code_block("objectivec") do %>
           [anObject theMethodName];
          <% end %>

          Method names in Objective C follow the form initialMethodNameAndArgument:theSecondArgument:theThirdArgument: .

          <% block("Messages vs. Methods") do %>
            When you see references to "calling a method" or "calling a function" on an object in Objective C, it's best to
            consider these synonymous with "dispatching a message".  Objective C objects respond to
            <%= highlight("messages") %>, and as you work more with Objective C, it will be more beneficial for
            you to perceive this as such.
          <% end %>
    - "nil, NULL":
        notes: >
          An object in Objective C may be nil; nil is a "special" object which may have any message at all sent to it,
          to which it will respond with a nil object.

          <% code_listing("nil object responding to any message", "objectivec") do %>
            NSString * anObject = nil;
            if([anObject whoaThisProbablyDoesntExist] == nil){
              NSLog(@"Ah well");
            }
          <% end %>

          nil is the appropriate null object when dealing with pointers to Objective C classes; NULL, on the other
          hand, is the appropriate null value to use when dealing with pointers to all other types.
    - "Classes":
      notes:
        - >
          Classes in Objective C are similar to their C++ cousins in that they come in two parts: interface declaration
          and implementation. The interface declaration portion of a class follows the form:

          <% code_listing("Class interface declaration", "objectivec") do %>
            #import <Foundation/Foundation.h>
            @interface MyNewClass : NSObject {
              int privateVariable1;
              NSString * privateVariable2;
            }

            +(int) someClassMethod;
            -(void) doSomething;
            -(NSString *) giveMeAStringOfLength:(int)length
                              randomizeContents:(BOOL)randomize;
            @end
          <% end %>
        - >
          The implementation of this class follows the form:

          <% code_listing("Class implementation", "objectivec") do %>
            #import "MyNewClass.h"

            @implementation MyNewClass

            -(id) init {
              if(self = [super init]){
                privateVariable1 = 20;
                privateVariable2 = [[NSString alloc] initWithString:@"Test"];
              }
              return self;
            }

            +(int) someClassMethod {
              return 0;
            }

          <% end %>
        - >
          <% code_listing("Class implementation pt. 2", "objectivec") do %>
            -(void) doSomething {
              NSLog(@"Something");
            }

            -(NSString *) giveMeAStringOfLength:(int)length
                              randomizeContents:(BOOL)randomize {
              return @"TODO: Make work";
            }

            -(void) dealloc {
              [privateVariable2 release];
              [super dealloc];
            }

            @end
          <% end %>
    - "Memory management":
        notes:
          - >
            Objective C's memory management model is a reference counting system
            that you can think of as an integer counter assigned to each object.
            Each object, when initialized, starts with a counter equal to 1.  When
            this counter reaches 0, the cleanup functions (dealloc) on the object
            are called and the memory for the object is released back to the system.
          - >
            <% code_listing("Memory management in Objective C", "objectivec") do %>
              // Retain count of 1
              NSString * foo = [[NSString alloc] initWithString:@"Foo"];
              [foo retain]; // Retain count of 2
              NSLog(@"Foo is %@", foo);
              [foo release]; // Retain count of 1
              NSLog(@"Foo is still %@", foo);
              [foo release]; // Retain count of 0,
                             // foo is released back to the system

              // This will crash the program (EXC_BAD_ACCESS)
              NSLog(@"Foo crashes %@", foo);
            <% end %>
            <% block("EXC BAD ACCESS ? What?") do %>
              EXC BAD ACCESS is the error message your program will output when
              it attempts to do something to a pointer to a memory location
              whose contents have previously been released to the system.
            <% end %>
          - >
            You can indicate you don't want to manage the release of an object by
            indicating an object should be autoreleased objects.  Autoreleased objects
            are managed by an object called an NSAutoreleasePool, and are intermittently
            checked to see how many references have been claimed on them.  The pool will
            release the object "at some unknown point in the future"* once all  retains on
            the object have been released.
          - >
            <% code_listing("Memory management in Objective C", "objectivec") do %>
              // Indicate that the foo object should be managed by
              // the current NSAutoreleasePool
              NSString * foo = [[[NSString alloc]
                                           initWithString:@"Foo"]
                                             autorelease];
              NSLog(@"Foo will be good for now %@", foo);

              [foo retain];
              [foo release];
              NSLog(@"Foo is still good, %@", foo);
              // You may retain and release on an autoreleased object as normal

              [foo release];
              // Calling an 'unbalanced release' like this will cause a crash
              // at some unknown point in the future
            <% end %>
          - >
            Different classes in Cocoa / Objective C have different rules about how they retain
            objects.  The documentation is instructive in telling you what memory management
            semantics you should expect from given functionality.

            <% block("Mac Programmers Have All The Luck") do %>
              Should you be programming Mac OS applications as opposed to iOS applications,
              you can take advantage of garbage collection memory management which has been
              available since Mac OS Leopard (10.5); iOS programmers still have to manage their
              memory themselves, however.
            <% end %>
    - "Properties":
        notes:
          - >
            Much of the interaction with Objective C objects equates to the usual getter/setter
            functionality commonly associated with Object Oriented Programming. To make it easier
            for programmers to declare this functionality, properties were introduced as a way
            to eschew all the boilerplate code and provide a common framework upon which to
            enhance Objective C objects.
          - >
            <% code_listing("Property interface declaration", "objectivec") do %>
              @interface MyObject : NSObject {
                NSString * instanceVariable;
                float numericVariable;
              }
              @property(readwrite, retain) NSString * instanceVariable;
              @property(readonly, assign) float numericVariable;
              @end

              @implementation MyObject

              @synthesize instanceVariable;
              @synthesize numericVariable;

              -(void) dealloc {
                [instanceVariable release];
                [super dealloc];
              }

              @end

            <% end %>
          - >
            <% code_listing("Property usage", "objectivec") do %>
              MyObject * mo = [[MyObject alloc] init];
              [mo setInstanceVariable:@"Test"];
              [mo setNumericVariable:20.0f];
              NSLog(@"The values I set were %@ and %f",
                      [mo instanceVariable],
                      [mo numericVariable]);
            <% end%>
          - >
            You can specify the memory management semantics (retain, assign, copy) in the property
            declaration.  You can also specify the atomicity (locking behavior) of the property,
            and more.

            <% block("More to it..") do %>
              Properties do not merely provide getter/setter functionality.  The use of properties
              also implicitly adds Key-Value-Observing functionality to your class, letting
              you automatically monitor classes for change events and performing specific code
              in such cases.  Read more at <%= url("http://developer.apple.com/mac/library/documentation/cocoa/conceptual/objectivec/articles/ocProperties.html") %>.
            <% end %>
    - "Selectors":
        notes:
          - >
            Selectors in Objective C are a way to provide a special type to indicate a message.
            They allow you to dynamically send a message to an object, as well as to query
            an object to see if it responds to a given message.
          - >
            <% code_listing("Selector usage", "objectivec") do %>
              SEL aSelector = @selector(length);
              NSString * foo = @"Foo";
              if([foo respondsToSelector:aSelector]){
                NSLog(@"The length of foo is %i",  [foo performSelector:aSelector]);
              }

            <% end %>
          - >
            Selectors can be built from strings, and can refer to any Objective C message
            that is forwarded to an object.
            <% code_listing("Other selector usage", "objectivec") do %>
              NSString * aUserSuppliedString = MagicallyGetStringFromUserInput();
              SEL aSelector = NSSelectorFromString(aUserSuppliedString);
              if([someObject respondsToSelector:aSelector]){
                // NOTE: Surely nothing bad will happen
                [someObject performSelector:aSelector];
              }
            <% end %>
    - "Protocols":
        notes:
          - >
            Objective C provides only single-inheritance for its objects; to
            allow for situations where a class may provide functionality outside of its
            inheritance chain, the language provides Protocols, which are roughly analogous
            to interfaces in Java and C\#.  There are informal protocols (only referred to in
            documentation) and formal protocols, which are compiler checked.  The majority of
            protocol usage in iOS programming is formal protocols.
          - >
            <% code_listing("Protocol declaration", "objectivec") do %>
              @protocol TestProtocol

              -(void) definitelyHasThisMethod;

              @optional

              -(void) mayHaveThisMethod;

              @end
            <% end %>
            <% code_listing("Protocol conformance", "objectivec") do %>
            @interface SomeObject : NSObject<TestProtocol> {

            }

            @end
            <% end %>
          - >
            <% code_listing("Protocol usage", "objectivec") do %>
              SomeObject<TestProtocol> * oo = [[SomeObject alloc] init];

              // We assume this because the object conforms to TestProtocol
              [oo definitelyHasThisMethod];

              if([oo respondsToSelector:@selector(mayHaveThisMethod)]){
                [oo mayHaveThisMethod];
              }
            <% end %>
    - "Categories":
        notes:
          - >
            Categories allow you to mix in new code to existing classes without
            having to change the original source code for those classes.  Examples
            of categories include automatically adding special serialization rules
            to NSObject, or special data structure Queue behavior to Cocoa collection
            classes.

            <% alertblock("Except for..") do %>
              You can't add instance variables to a class with categories; they are
              purely for adding new methods to a class, but cannot change the memory
              layout of a class after the fact.
            <% end %>
          - >
            <% code_listing("Category declaration", "objectivec") do %>
              @interface NSString(FunkyStrings)

              -(NSString *) getFunky;

              @end

              @implementation NSString(FunkyStrings)

              -(NSString *) getFunky {
                return [self stringByAppendingString:@"...YEAH! ALL RIGHT! FEELS GOOD!"];
              }

              @end
            <% end %>
          - >
            <% code_listing("Category usage", "objectivec") do %>
            #import "NSString+FunkyStrings.h"

            void main(){
              NSLog(@"The funkiest string by far is %@", [@"James Brown" getFunky]);
            }
            <% end %>
    - "Review common useful classes in Objective C / Cocoa to accomplish certain tasks":
        notes:
          - >
            There are a host of useful classes in the Cocoa Touch framework that provide
            special functionality to you.  Some of the more common objects you'll use
            in your programming are NSArray, NSDictionary, NSNumber and NSString.  Each of these objects
            have mutable versions that allow you to modify them after instantiation.
          - >
            NSString is an enhanced, unicode aware string class that goes far beyond the
            simple byte-array behavior of C's byte-array strings.

            <% code_listing("NSString usage", "objectivec") do %>
              NSString * s = [[NSString alloc] initWithCString:"this is an ascii string"
                                               encoding:NSASCIIStringEncoding];
              NSMutableString * so = [[NSMutableString alloc]
                                              initWithString:@"A mutable string with..."];

              [so appendString:s];

              NSLog(@"The mutable string is %@", so);

              [so release];
              [s release];
            <% end %>
          - >
            NSNumber is a simple abstract wrapper around numeric values which allows you to
            automatically convert its held value to the appropriate form, as well as having
            an object-like representations of a numeric value.

            <% code_listing("NSNumber usage", "objectivec") do %>
              NSNumber * n = [[NSNumber alloc] initWithFloat:20.0f];
              double d = [n doubleValue];
              int i = [n intValue];
              [n release];
            <% end %>
          - >
            NSDictionary is a generic dictionary object that you can use to hold key/value associations.
            A key can be any NSObject that responds to isEqual: and NSCopying; in most cases, your
            keys will be either NSString or NSNumber objects.
          - >
            <% code_listing("NSDictionary usage", "objectivec") do %>
              NSDictionary * a = [[NSDictionary alloc] initWithObjectsAndKeys:
                                                    @"The foo string", @"Foo",
                                                    @"The bar string", @"Bar",
                                                    nil];

              NSMutableDictionary * b = [[NSMutableDictionary alloc] init];
              [b setObject:@"Another string" forKey:[NSNumber numberWithInt:20]];

              NSLog(@"a's alue for Foo is %@, and b's value for 20 is %@",
                                        [a objectForKey:@"Foo"],
                                        [b objectForKey:[NSNumber numberWithInt:20]]);

              for(id key in a){
                NSLog(@"The value for %@ is %@", key, [a objectForKey:key]);
              }

              [b release];
              [a release];
            <% end %>
          - >
            NSArray is a simple way to collect NSObject inheriting classes into a sequential
            list.  NSArray automatically retains each object added to it, and releases each object
            it holds once its own retain count has reached 0.

            <% code_listing("NSArray usage", "objectivec") do %>
              NSArray * a = [[NSArray alloc] initWithObjects:@"Foo", @"bar", @"baz", nil];
              NSMutableArray * b = [[NSMutableArray alloc] init];
              [b addObject:@"Not foo"];
              NSLog(@"The contents of a are %@ and b are %@", a, b);

              for(NSString * obj in a){
                NSLog(@"The array contains %@", obj);
              }

              [a release];
              [b release];
            <% end %>
          - >
            NSArray, NSDictionary, NSString and NSNumber may all be represented by the contents of
            a property list file ( Plist ).  You can easily rebuild an NSArray or NSDictionary full
            of the property list contents by using the initialization method <%= highlight("initWithContentsOfFile:") %>
          - >
            <% figure("Sample Property List") do %>
              <%= graphic("PListExample1.png", 0.5) %>
            <% end %>

            <% code_listing("Property List Deserialization", "objectivec") do %>
              NSDictionary * example = [[NSDictionary alloc]
                                           initWithContentsOfFile:@"/path/to/sample.plist"];
              NSLog(@"The subarray contents are %@",
                         [example objectForKey:"A subarray of values"]);
              [example release];
            <% end %>
    - "More learning":
        notes:
          - >
            Objective C is a rich, deep language.  There are lots of resources on the web and your computer where you can learn more.
            The best is easily the XCode documentation, but there are blogs out there that can provide invaluable help: Mike Ash's
            NSBlog <%= url("http://www.mikeash.com/pyblog/") %>,  Cocoa With Love <%= url("http://cocoawithlove.com/") %>,
            and the Apple Developer Forums <%= url("http://developer.apple.com/devforums/") %> can all provide invaluable help
            in learning new techniques and advanced usage for your apps.
  - "iPhone App Layout Conventions":
    - "MVC, as applied to an app":
        notes:
          - >
            Apple strongly encourages you to adhere to Model View Controller pattern
    - "Application -> Window -> View Controller(s) -> View(s) + Models":
        notes:
          - >
            On iOS, a UIApplication ( your app ) typically has one UIWindow, which is the primary
            UIView upon which everything else displays.  A UIView is just a rectangle upon which you draw things.
          - >
            Almost everything visual is a UIView (except the things that aren't).
          - >
            <% figure("UIViews are everything") do %>
              <%= graphic("UIViewExample.pdf", 0.35) %>
            <% end %>
          - >
            <% figure("UIViews are almost everythign") do %>
              <%= graphic("UIViewExample2.pdf", 0.35) %>
            <% end %>
          - >
            UIViewControllers are objects that manage what the views on screen are currently doing; typically
            where you write event handling code and user interaction code.
          - >
            You provide the model
    - "UINavigationController":
        notes:
          - >
            UINavigationController is a stack based manager of view controllers that the user can navigate through
          - >
            <% figure("Items managed by UINavigationController ") do %>
              <%= graphic("UIViewExample3.pdf", 0.35) %>
            <% end %>
          - >
            Every UIViewController managed by a UINavigationController has a reference to that UINavigationController
          - >
            <% code_listing("Adding another UIViewController to the UINavigationController stack", "objectivec") do %>
              MyViewController * controller = [[MyViewController alloc] initWithNibName:nil
                                                                        bundle:nil];
              [[self navigationController] pushViewController:controller animated:YES];
              [controller release];
            <% end %>
    - "Lab 2":
        notes:
          - >
            Create a new View based project
          - >
            Add a UINavigationController to MainWindow.xib
          - >
            Create a new view controller
          - >
            Add a button to the first view controller and create an action to open the second view controller
    - "UITabBarController and UITableViewController":
        notes:
          - >
            UITabBarController swaps in UIViewControllers assigned to it when users click on the associated button
          - >
            Each UIViewController has a tabBarItem property that UITabBarController uses to populate its UITabBar
          - >
            <% figure("UITabBarController example") do %>
              <%= graphic("UIViewExample4.pdf", 0.30) %>
            <% end %>
          - >
            UITableViewController instructs a UITableView about the number of rows it contains, what to do when
            clicked, the number of sections, and other information
          - >
            UITableViewController is just a convenience class that saves you from manually conforming an object
            to the UITableViewDataSource and UITableViewDelegate protocols
          - >
            <% figure("UITableView example") do %>
              <%= graphic("UIViewExample5.pdf", 0.30) %>
            <% end %>
    - "Lab 3":
        notes:
          - >
            Add a UITableViewController to the project
          - >
            Add an NSArray containing names from the class to the controller
          - >
            Change the Interface builder reference to the UITableViewController
    - "Modal view controllers":
        - >
          Not all view controllers fit within the "display in UINavigationController" or "display in UITabBarController"
          model.
        - >
          <% figure("UIImagePickerController") do %>
            <%= graphic("UIViewExample6.pdf", 0.35) %>
          <% end %>
        - >
          <% figure("MFMailComposeViewController") do %>
            <%= graphic("UIViewExample7.pdf", 0.35) %>
          <% end %>
        - >
          You can present a view controller modally by using the presentModalViewController:animated: message

          <% code_listing("Presenting a view controller modally", "objectivec") do %>
            -(IBAction) buttonClicked:(id) sender {
              MyViewController * mvc = [[MyViewController alloc]
                                             initWithNibName:@"TheNib"
                                             bundle:nil];
              [self presentModalViewController:mvc animated:YES];
              [mvc release];
            }
          <% end %>
        - >
          You can specify the transition style with which the view controller appears via the UIViewController message
          <% code_block("objectivec") do %>
            setModalTransitionStyle:(UIModalTransitionStyle)style
          <% end %>
  - "XCode and Interface Builder":
    - "Capabilities":
        notes:
          - >
            XCode and Interface Builder combined provide a development, debugging and interface development tool for you to
            develop your iPhone apps.  It can integrate with SVN, CVS or Perforce ( and soon, Git! ), it can run automated
            tests on your code, provide inline documentation assist, code completion and a lot more. It also provides a developer
            level interface to all the devices you will be debugging your code on; you can manage devices and device profiles
            through XCode as necessary.
    - "Creating an app":
        notes:
          - >
            XCode provides a number of application templates for starting an app.  Most basic types of applications can get
            a fast start by using one of these app templates.
            <% figure("XCode New Project window") do %>
              <%= graphic("ProjectCreator.png", 0.35) %>
            <% end %>
          - >
            Once you've selected the type of app you want to create, your project will be created with an application delegate
            and usually at least one view controller that will manage what goes on the screen.  It will also have a .xib file
            for your application, and for each view controller in the app, that is used by Interface Builder to layout the screen contents.
            <% figure("New Project File List") do %>
              <%= graphic("ProjectFileList.png", 0.75) %>
            <% end %>
            <% block("The application delegate - UIApplicationDelegate") do %>
              The application delegate ( UIApplicationDelegate protocol ) is the class which will respond to overall application lifecycle events,
              like when your application has started, resumed from suspension, or is about to shut down.
            <% end %>
          - >
            Double clicking on a .xib file will open it in Interface Builder, where you can drag components from the Interface Builder
            toolbox into the view.  You can easily change the orientation of objects.
    - "Documentation usage":
        notes:
          - >
            <%= highlight("Help - Developer Documentation") %> is an invaluable resource for researching Cocoa internals.
    - "Protips!":
        notes:
          - >
            Learn hotkeys! ( CMD+SHIFT+D  and CMD+0 will buy you hours )
          - >
            Make XCode fit you ( Single window interface, XCode themes, application templates )
          - >
            XCode plugins ( Code Pilot <%= url("http://mac.brothersoft.com/code-pilot-for-xcode.html") %>, Accessorizer <%= url("http://www.kevincallahan.org/software/accessorizer.html") %> )
  - "Questions"
- subtitle: "Day 2"
  title: "iOS Application Development"
  author: "Chris Zelenak"
  date: "06/23/2010"
  sections:
  - "Images":
    - "The UIImage":
        notes:
          - >
            A way to represent a bytestream
          - >
            Does NOT give you access to the underlying image data
          - >
            Can be made from any given iPhone UI screen
          - >
            Carries with it a lower level CGImageRef object
            <% code_block("objectivec") do %>
              CGImageRef theImage = [aUIImage CGImage];
            <% end %>
          - >
            Can be loaded in cache form with
            <% code_block("objectivec") do %>
              UIImage * img = [UIImage imageNamed:@"ImageFilename.png"];
            <% end %>
            or loaded in no-cache form with
            <% code_block("objectivec") do %>
              NSBundle * bnd = [NSBundle mainBundle];
              NSString * path = [bnd pathForResource:@"ImageFilename" ofType:@"png"];
              UIImage * img = [[UIImage alloc] initWithContentsOfFile:path];
            <% end %>
          - >
            UIImage can handle most basic image types: PNG, JEPG, GIF, ICO, BMP, TIF..
          - >
            But the fastest way to load and draw images will typically be with PNGs.
    - "UIImageView and UIButton":
        notes:
          - >
           UIImageView provides a simple way to put an image on the screen, w/ no interaction
          - >
            <% code_listing("Loading a UIImageView with an image", "objectivec") do %>
              UIImageView * v = [[UIImageView alloc]
                                  initWithFrame:CGRectMake(0.0, 0.0, 200.0, 200.0)];
              UIImage * someImage = [UIImage imageNamed:@"screenImage.png"];
              [v setImage:someImage];
              [someView addSubview:v];
              [v release];
            <% end %>
          - >
            UIButton can also show an image instead of a rounded rectangle.  It can display different
            images for both foreground and background based on its current state as well.
          - >
            <% code_listing("Loading a UIButton with an image", "objectivec") do %>
              UIButton * b = [UIButton buttonWithType:UIButtonTypeCustom];
              [b setImage:[UIImage imageNamed:@"btnImage.png"]
                 forState:UIControlStateNormal];
              [b setBackgroundImage:[UIImage imageNamed:@"btnImageSelectedBG.png"]
                           forState:UIControlStateSelected];
              [someView addSubview:b];
            <% end %>
    - "Lab 4":
        notes:
          - >
            Create a detail UITableViewController
          - >
            Load in class images in header with student name
          - >
            Push UITableViewController onto UINavigationController stack
  - "More about UIView and Core Graphics":
    - "What comes with UIView":
        notes:
          - >
            Any UIView can have its background color, overall opacity,  dimensions and overall coordinate transform (CGAffineTransform)
          - >
            Any UIView can contain any number of subviews
          - >
            Any UIView can have specific autoresizing behavior applied to it when its parent view changes
          - >
            Any UIView can automatically resize its subviews when its dimensions change
          - >
            Any UIView subclass can choose to respond to direct touch events
          - >
            Any UIView can optionally choose to blit its contents directly to the screen with Core Graphics
    - Views and subviews:
        notes:
          - >
            The subviews a UIView has are contained within the subviews property of a view
          - >
            You can see the subviews of a view layed out in Interface Builder by expanding the View in the Document view
            <% figure("Expanding the contents of a UIView") do %>
              <%= graphic("UIViewExpand.png", 0.5) %>
            <% end %>
          - >
            Views overlay each other based on the order they are added to the parent view; you can swap their order by using
            UIView methods like
            <% code_block("objectivec") do %>
              -(void) bringSubviewToFront:(UIView *)view;
              -(void) sendSubviewToBack:(UIView *)view;
              -(void) exchangeSubviewAtIndex:(NSInteger)idx withSubviewAtIndex:(NSInteger)idx;
            <% end %>
    - "Events and control events":
        notes:
          - >
            Any UIView subclass can override the methods

            <% code_listing("Touch events", "objectivec") do %>
              - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;
              - (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;
              - (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;
              - (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;
            <% end %>

            and perform their own logic when the view is touched.
          - >
            The NSSet passed to each of the event handling methods is full of
            UITouch objects, which can give you information about where specifically
            in a view the touch occurred.

            <% alertblock("Multi-touch") do %>
              If you want to provide multi-touch interactivity with your view,
              ensure that you have set the multipleTouchEnabled property of your
              view to YES.
            <% end %>
          - >
            UIControl objects ( like UIButton ) offer more flexibility for responding
            to events by allowing you to assign specific selectors to be called
            at specific touch event times.

            <% code_listing("Handling UIButton events", "objectivec") do %>
              UIButton * b = [UIButton buttonWithType:UIButtonTypeCustom];
              [b addTarget:self action:@selector(wasTouched:)
                 forControlEvents:UIControlEventTouchDown];
              [b addTarget:self action:@selector(wasDraggedOut:)
                 forControlEvents:UIControlEventTouchDragOutside];
            <% end %>
    - "Position, size and color of views - CGRect, CGPoint, CGSize, UIColor":
        notes:
          - >
            Each UIView has a bounding frame and origin coordinate that specifies where
            in the parent view it appears; this is represented by a CGRect, which is a
            combination of CGPoint and CGSize .
          - >
            CGRect, CGPoint and CGSize are all simple C-structs; they each have simple
            C constructor methods which make working with them easier:
            <% code_listing("CG struct constructor methods", "objectivec") do %>
              CGRect myFrame = CGRectMake(0.0, 0.0, 200.0, 128.0);
              CGPoint myPoint = CGPointMake(0.0, 10.0);
              CGSize mySize = CGSizeMake(200.0, 128.0);
            <% end %>
          - >
            They are used universally throughout UIKit whenever ascertaining the
            location or dimensions of an object need to be queried.
          - >
            The CGAffineTransform of a view modifies the /at render time/ value
            of coordinates, not the logical value you've assigned.
          - >
            UIColor can be used to specify any common color value combination
            you wish to apply to an object.
          - >
            UIColor provides a host of simple convenience methods for accessing
            commonly used colors.

            <% code_listing("UIColor usage", "objectivec") do %>
              UIColor * c = [UIColor blackColor];
              UIColor * oc = [UIColor colorWithRed:1.0
                                             green:0.0
                                              blue:0.0
                                             alpha:0.75];
              UIImage * pattern = [UIImage imageNamed:@"myTileImage.png"];
              UIColor * pt = [UIColor colorWithPatternImage:pattern];
            <% end %>
    - "drawRect:":
        notes:
          - >
            Some effects aren't easily achieved through UIViews and drawn images.  To
            draw your view components manually, you can override the drawRect method
            and manually blit your graphics to the screen.
          - >
            When drawing your graphics manually, you need to acquire a handle to the
            graphics surface.  In Core Graphics, this is the CGContextRef, and you can
            get a handle to it by using UIKit to get the current valid context.

            <% code_listing("Core Graphics context", "objectivec") do %>
              -(void) drawRect:(CGRect) frame {
                CGContextRef context = UIGraphicsGetCurrentContext();
                CGContextSetFillColor(context, [[UIColor redColor] CGColor]);
                CGContextFillRect(context, frame);
              }
            <% end %>
  - "UIView Animation":
    - "UIView beginAnimations / commitAnimations":
        notes:
          - >
            You can easily use Core Animation to animate any of your
            UIViews by using the beginAnimations  and commiteAnimations messages.
          - >
            <% code_listing("Example animation", "objectivec") do %>
              [UIView beginAnimations:nil context:NULL];
              [someView setAlpha:0.0];
              [UIView commitAnimations];
            <% end %>
          - >
            Most properties that affect a view's appearance are able to be animated,
            including size, position, arrangement with respect to other subviews  and transparency.
    - "Controlling the animation":
        notes:
          - >
            You can set special properties for the animation inside the animation block.
            These properties include duration, animation curve, delay for animation and
            completion callbacks.
          - >
            The animation curve specifies the easing behavior of an animation - you can set the
            animation to be linear, ease in, ease out or ease in and out.
            <% code_listing("Setting easing behavior", "objectivec") do %>
              [UIView beginAnimations:nil context:NULL];
              [UIView setAnimationCurve:UIViewAnimationCurveEaseOut];
              [someView setFrame:CGRectMake(newX, newY, newWidth, newHeight)];
              [UIView commitAnimations];
            <% end %>
          - >
            The animation duration and delay indicate how long the animation will run,
            and how long the animation will wait before running, respectively.
            <% code_listing("Setting duration and delay", "objectivec") do %>
              [UIView beginAnimations:nil context:NULL];
              [UIView setAnimationDuration:12.0]; // 12 sec
              [UIView setAnimationDelay:1.0]; // wait 1 sec before playing
              [someView setAlpha:0.45];
              [UIView commitAnimations];
            <% end %>
          - >
            You can specify a delegate to receive start and stop selectors when the animation
            first begins and when the animation ends as well.
          - >
            <% code_listing("Handling animation start/stop events", "objectivec") do %>
              -(void) beginAnimation {
                [UIView beginAnimations:nil context:(void *)theView];
                [UIView setAnimationDelegate:self];
                SEL didStop = @selector(animDidStop:finished:ctxt:);
                SEL wilLStart = @selector(animWillStart:finished:ctxt:);
                [UIView setAnimationDidStopSelector:didStop];
                [UIView setAnimationWillStartSelector:willStart];
                [theView setAlpha:0.0];
                [UIView commitAnimations];
              }
            <% end %>
          - >
            <% code_listing("Handling animation start/stop events pt. 2", "objectivec") do %>
                -(void) animWillStart:(NSString *)animid
                                 ctxt:(void *)context {
                  NSLog(@"Started fade out");
                }

                -(void) animDidStop:(NSString *)animid
                           finished:(BOOL)finished
                               ctxt:(void *)context {
                  UIView * v = (UIView *) context;
                  [v removeFromSuperview];
                  NSLog(@"Removed faded view");
                }
            <% end %>
    - "Lab 5":
        notes:
          - >
            Create a UITableViewCell subclass
          - >
            Add a front and back image view to the UITableViewCell
          - >
            Properly use the new cell subclass in the detail view controller
          - >
            Add an image swap method to the subclass
          - >
            Swap the images when touched
          - >
            Correctly adjust the cell text to make room for the new image
  - "UIView and CALayer - Coordinate systems, layer backing":
    - "UIViews each containing a layer":
        notes:
          - >
            Each UIView contains an object called a CALayer; this layer
            represents the final output of the view to be rendered to
            screen.
          - >
            The CALayer object of a UIView may contain sublayers.
            The tree hierarchy of UIViews is functionally identical
            to the tree hierarchy of CALayers.
          - >
            The coordinate system of a UIView is not identical to the
            coordinate system of a CALayer.
    - "The contents attribute of a CALayer":
        notes:
          - >
            Each CALayer has a property called contents which is intended
            to hold a CGImageRef.
          - >
            Alternatively, a CALayer may have a delegate assigned to it,
            whose job it is to render content to a supplied CGContextRef.
          - >
            The layer that is created for each UIView has its delegate
            assigned to that UIView.
    - "How the above animation actually occurs under the hood ( brief reference to CATransaction )":
        notes:
          - >
            CALayers are the lower level manifestation of UIView animation.
          - >
            The animation calls at the UIView level boil down to operations
            inside a CATransaction.
          - >
            CATransactions imply batch operations upon a known "current state"
            of a CALayer; once the transaction has been committed,
            the values will be changed for the duration of the
            CATransaction on the modelLayer of a layer, and flushed to the
            presentationLayer.
    - "Similarities and differences between a CALayer and a UIView":
        notes:
          - >
            Both have transform properties; CGAffineTransform for UIView,
            CATransform3D for CALayer. CALayer allows for simple depth changes
            to a given layer's contents.
          - >
            The origin for CALayer's is centered; the origin for UIViews is
            at the upper left of the view.
          - >
            CALayers have no input model to speak of; CALayer subclasses
            need to be explicitly notified of user input.
    - "Reference to CATiledLayer and performance optimizations":
        notes:
          - >
            CALayers abstract how image content is batched to the graphics
            subsystem.  With large ( greater than 2048x2048 ) image content, it becomes
            necessary to partition the content into smaller chunks.
          - >
            CATiledLayer lets you build Google Maps style tiling of
            images into manageable chunks for the graphics hardware.
          - >
            Automatically computes the desired tile size for a given
            display areo and zoom level.
  - "Questions"
- subtitle: "Day 3"
  title: "iOS Application Development"
  author: "Chris Zelenak"
  date: "06/24/2010"
  sections:
    - "Core Data and SQLite":
      - "NSManagedObject and beyond":
          notes:
            - >
              NSManagedObject is the primary element of working with your core
              data store. It represents a single entity's worth of information
              in the database that backs your app. The actual data for the
              entity is able to be queried via the valueForKey and setValue:forKey:
              methods of NSManagedObject.
            - >
              NSManagedObject changes are queued to an NSManagedObjectContext
              which is roughly equivalent to a database transaction; it provides
              locking, commit/rollback and undo/redo functionality for
              object changes.
            - >
              NSEntityDescription describes the schema associated with
              a specific type of NSManagedObject; a database table is similar
              in the way that it describes the layout of its child rows.
            - >
              NSManagedObjectModels are created by the programmer, and are
              collections of NSEntityDescriptions.
            - >
              NSPersistentStore represents the actual physical location of
              your Core Data objects, and can be a database, an XML file,
              or any other other physical manifestation of data for
              which an NSPersistentStore has been written.
            - >
              You can create your own NSManagedObjectModel subclasses that
              provide convenient abstractions over NSManagedObjectModel.
            - >
              To get an instance of an NSManagedObject that is able to be
              saved to the NSPersistentStore, use:

              <% code_listing("Getting a new NSManagedObject that will eventually be saved to an NSPersistentStore", "objectivec") do %>
                NSManagedObject * newObject = [NSEntityDescription
                                               insertNewObjectForEntityForName:@"EntityName"
                                               inManagedObjectContext:managedObjectContext];
              <% end %>
            - >
              To save changes to all current NSManagedObjects currently managed
              by an NSManagedObjectContext:

              <% code_listing("Saving changed objects", "objectivec") do %>
                NSError * error = nil;
                [managedObjectContext save:&error];
                if(error){
                    NSLog(@"Couldn't save objects, %@", error);
                }
              <% end %>
      - "NSPredicate and NSFetchRequest":
          notes:
            - >
              Actually fetching objects from the Core Data store requires you
              to build queries using NSPredicate or NSFetchRequest.
            - >
              The syntax for NSPredicate and NSFetchRequest requests is
              similar to SQL, but not identical.
            - >
              <% code_listing("NSPredicate example", "objectivec") do %>
                NSPredicate * searchPredicate = [NSPredicate
                                         predicateWithFormat:@"(firstName = 'Chris') AND "
                                                      @"(lastName BEGINSWITH 'Zel') AND "
                                                      @"(age BETWEEN {%i,%i})", 20, 30];
              <% end %>
              <% block("See more..") do %>
                Read more about writing NSPredicates in the "Predicate Programming Guide" in
                the XCode documentation.
              <% end %>
            - >
              You can also build named NSFetchRequests in the .xcdmodel
              for your entities.
              <% figure("Predicate builder") do %>
                <%= graphic("PredicateBuilder.png", 0.5) %>
              <% end %>
            - >
              <% code_listing("Stored NSPredicate example", "objectivec") do %>
                NSFetchRequest * req = [managedObjectModel
                                         fetchRequestFromTemplateWithName:@"requestByName"
                                         substitutionVariables:[NSDictionary
                                            dictionaryWithObjectsAndKeys:
                                              @"Pwnsberry", @"LAST_NAME", nil]];
              <% end %>
      - "Lab 6":
          notes:
            - >
              Create a property list with the names of the students in the class
            - >
              Create the xcdmodel that describes the entities
            - >
              Initialize the Core Data persistence layer
            - >
              Use NSUserDefaults to detect whether or not the app has been started before
            - >
              Perform the import if the app has never been started before
            - >
              Pass the user and image data on to the details controller
    - "Networking ( NSURLRequest )":
      - "NSURL, NSURLRequest,  NSMutableURLRequest AND NSURLConnection":
          notes:
            - >
              NSURL is meant to only represent a single resource location
            - >
              NSURL can be allocated to represent either a filesystem location,
              or a web resource
            - >
              NSURLRequest and NSMutableURLRequest represent specific
              web resources that you'd like to initiate a connection to;
              NSURLRequest should be used for simple GET HTTP requests,
              while NSMutableURLRequests can be used for more complex
              HTTP requests.
            - >
              NSMutableURLRequest allows you to set HTTP headers,
              the HTTP method used, and the request body.
            - >
              NSURLRequest and NSMutableURLRequest both by default
              only work with HTTP requests
            - >
              NSURLConnection initiates the download and returns
              the NSHTTPURLResponse which contains the body of the
              response, as well as http status code and
              response headers.
            - >
              NSURLConnection can send data both synchronously
              or asynchronously; the response information is passed
              back to the connection delegate via the
              informal NSURLConnection delegate.
      - "Networking Lab":
          notes:
            - >
              Create a new UIVIewController
            - >
              Add an NSURLConnection object
            - >
              Download the plist object and deserialize it
            - >
              Load the tableView with the new data
      - "( ASIHttpRequest, EasyURLDownloader )":
          notes:
            - >
              ASIHttpRequest gives you a full-featured HTTP library
              enhancement; cookie persistence support, enhanced
              HTTP auth support, S3 support and more.
              <%= url("http://github.com/pokeb/asi-http-request/") %>
            - >
              EasyURLDownloader gives you a simple library to
              perform asynchronous GET downloads in the background
              <%= url("http://github.com/netshade/EasyUrlDownloader") %>
      - "SOAP and REST Webservices":
          notes:
            - >
              You can roll your own webservice access, but you
              don't have ot.
            - >
              ObjectiveResource makes accessing REST services
              with ObjectiveC incredibly easy.
            - >
              WSMakeStubs will create stubs for you that shim out
              the available endpoints of a WSDL web service.
            - >
              ObjectiveResource is available at
              <%= url("http://github.com/yfactorial/objectiveresource") %>
            - >
              WSMakeStubs is a binary included with your SDK
    - "Getting your application on the device":
      - "Development certificates, Distribution certificates":
          notes:
            - >
              Log in to the iPhone developer portal and request a developer certificate
            - >
              Explain Key requests
            - >
              Download and install certificate
            - >
              Create development provisioning profile with devices
            - >
              Assign development provisioning profile
            - >
              AdHoc and Store based distribution reserved for Agents only
    - "Using Instruments":
      - "Always, always, always memory leak check":
          notes:
            - >
              Opening up the Leaks tool and examining your application behavior
            - >
              Examining specific leaks
            - >
              Understanding the Leaks tool
      - "Always, always, always activity monitor check":
          notes:
            - >
              Using Activity Monitor to monitor your current system state
    - "Distributing your app to others":
      - "The process you need to know":
          notes:
            - >
              Releasing your app to others in beta form
            - >
              What is an .ipa file
            - >
              How to send your .ipa file to others
      - "The URLs you need to know":
          notes:
            - >
              <%= url("http://developer.apple.com/iphone/") %> is the frontend to most
              Apple web services
            - >
              <%= url("http://itunesconnect.apple.com/") %> is the URL to access the app-release
              frontend and store management services provided by Apple
    - "Questions"
- subtitle: "Day 4.0"
  title: "iOS Application Development"
  author: "Chris Zelenak"
  date: "06/25/2010"
  sections:
    - "Overview of what's new in 4.0":
      - "Multitasking"
      - "Event Kit"
      - "Core Motion"
      - "Data Protection"
      - "Core Telephony"
      - "Assets Library"
      - "Quick Look framework"
      - "AVFoundation update"
      - "ImageIO"
      - "CoreMedia"
      - "CoreVideo"
    - "Hardware differences between devices":
      - "iPhone 2G"
      - "iPod Touch models"
      - "iPhone 3G"
      - "iPhone 3GS"
      - "iPad"
      - "iPhone 4"
    - "Device coordinate systems, logical points vs. physical pixels":
      - "Mapping points to pixels"
      - "Image naming schemes"
      - "iPad v. iPhone 4 v. iPhone earlier naming schems"
    - "Blocks in Objective C":
      - "Overview of blocks wrt function closures"
      - "Use of blocks in new iOS"
    - "Multiprocessing, Grand Central Dispatch":
      - "Use of blocks and queues in GCD"
    - "Accelerate":
      - "Preparing your application for iOS 4.0"
    - "Multitasking aware"
    - "Class overview, bits of information that didn't fit anywhere else"
    - "Thanks!"
